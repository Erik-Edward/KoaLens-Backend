# Steg 14: Prestandatestning

## Mål och syfte
Verifiera prestandan och latensen för den nya Gemini-implementationen för att säkerställa att den uppfyller kraven för användarupplevelse och skalbarhet. Detta steg fokuserar på att mäta, testa och optimera de prestandarelaterade aspekterna av applikationen för att garantera att den fungerar effektivt under olika belastningsförhållanden.

## Förutsättningar
- Implementation av Gemini API klar och funktionell
- Tillgång till testmiljö som liknar produktionsmiljön
- Testdata (bilder och videor av ingredienslistor i olika format)
- Testverktyg för prestandamätning
- Baseline-mätningar från Claude-implementationen för jämförelse

## Detaljerade instruktioner

### 1. Skapa prestandatestskript

Börja med att skapa ett script för att mäta prestandan på olika typer av analyser:

```typescript
// src/tests/performance/testPerformance.ts
import fs from 'fs';
import path from 'path';
import { AnalysisService } from '../../services/analysisService';
import { ImageAnalysisService } from '../../services/imageAnalysisService';
import { VideoAnalysisService } from '../../services/videoAnalysisService';
import { ClaudeService } from '../../services/claudeService';
import { GeminiService } from '../../services/geminiService';

// Hjälpfunktion för att mäta exekveringstid
async function timeExecution<T>(
  name: string,
  fn: () => Promise<T>
): Promise<{ result: T; executionTime: number }> {
  console.log(`Running test: ${name}`);
  const start = Date.now();
  
  try {
    const result = await fn();
    const executionTime = Date.now() - start;
    console.log(`✅ ${name} completed in ${executionTime}ms`);
    return { result, executionTime };
  } catch (error) {
    const executionTime = Date.now() - start;
    console.error(`❌ ${name} failed after ${executionTime}ms:`, error);
    throw error;
  }
}

// Funktion för att skapa test-rapporter
function generateReport(results: any[]) {
  const report = {
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    results: results,
    summary: {
      totalTests: results.length,
      totalTime: results.reduce((sum, r) => sum + r.executionTime, 0),
      averageTime: results.reduce((sum, r) => sum + r.executionTime, 0) / results.length,
      minTime: Math.min(...results.map(r => r.executionTime)),
      maxTime: Math.max(...results.map(r => r.executionTime))
    }
  };
  
  // Spara rapporten till fil
  const reportDir = path.join(__dirname, '../../reports');
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  
  const reportFile = path.join(reportDir, `performance_report_${Date.now()}.json`);
  fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
  
  console.log(`Report saved to ${reportFile}`);
  
  // Skriv ut en sammanfattning
  console.log('\n=== Performance Test Summary ===');
  console.log(`Total tests: ${report.summary.totalTests}`);
  console.log(`Total time: ${report.summary.totalTime}ms`);
  console.log(`Average time: ${report.summary.averageTime.toFixed(2)}ms`);
  console.log(`Min time: ${report.summary.minTime}ms`);
  console.log(`Max time: ${report.summary.maxTime}ms`);
  
  return report;
}

async function runPerformanceTests() {
  // Ladda testdata
  const textSamples = JSON.parse(fs.readFileSync(path.join(__dirname, 'data/text_samples.json'), 'utf8'));
  const imagePaths = JSON.parse(fs.readFileSync(path.join(__dirname, 'data/image_paths.json'), 'utf8'));
  const videoPaths = JSON.parse(fs.readFileSync(path.join(__dirname, 'data/video_paths.json'), 'utf8'));
  
  const analysisService = new AnalysisService();
  const imageAnalysisService = new ImageAnalysisService();
  const videoAnalysisService = new VideoAnalysisService();
  
  // Ladda Gemini och Claude services för jämförelse
  const geminiService = new GeminiService();
  const claudeService = new ClaudeService();
  
  const results = [];
  
  // 1. Testa textanalys med olika komplexitetsnivåer
  for (const sample of textSamples) {
    // Testa med Gemini
    const geminiResult = await timeExecution(`Gemini Text Analysis: ${sample.name}`, async () => {
      return await analysisService.analyzeIngredients(sample.ingredients);
    });
    
    results.push({
      test: `Gemini Text Analysis: ${sample.name}`,
      provider: 'Gemini',
      executionTime: geminiResult.executionTime,
      sampleSize: sample.ingredients.join(', ').length,
      complexity: sample.complexity
    });
    
    // Jämför med Claude om det är tillgängligt och konfigurerat
    try {
      const claudeResult = await timeExecution(`Claude Text Analysis: ${sample.name}`, async () => {
        // Skicka direkt till Claude service för jämförelse
        const prompt = `Analysera dessa ingredienser: ${sample.ingredients.join(', ')}`;
        return await claudeService.generateContent(prompt);
      });
      
      results.push({
        test: `Claude Text Analysis: ${sample.name}`,
        provider: 'Claude',
        executionTime: claudeResult.executionTime,
        sampleSize: sample.ingredients.join(', ').length,
        complexity: sample.complexity
      });
    } catch (error) {
      console.warn('Claude test skipped - service might not be available');
    }
  }
  
  // 2. Testa bildanalys med olika bildkvalitet/komplexitet
  for (const imagePath of imagePaths) {
    const geminiImageResult = await timeExecution(`Gemini Image Analysis: ${imagePath.name}`, async () => {
      return await imageAnalysisService.analyzeImage(imagePath.path);
    });
    
    results.push({
      test: `Gemini Image Analysis: ${imagePath.name}`,
      provider: 'Gemini',
      executionTime: geminiImageResult.executionTime,
      fileSize: fs.statSync(imagePath.path).size,
      complexity: imagePath.complexity
    });
  }
  
  // 3. Testa videoanalys
  for (const videoPath of videoPaths) {
    const geminiVideoResult = await timeExecution(`Gemini Video Analysis: ${videoPath.name}`, async () => {
      return await videoAnalysisService.analyzeVideo(videoPath.path);
    });
    
    results.push({
      test: `Gemini Video Analysis: ${videoPath.name}`,
      provider: 'Gemini',
      executionTime: geminiVideoResult.executionTime,
      fileSize: fs.statSync(videoPath.path).size,
      duration: videoPath.duration,
      complexity: videoPath.complexity
    });
  }
  
  // 4. Testa latens under belastning med parallella anrop
  const loadTestResults = await timeExecution('Gemini Load Test (10 parallel requests)', async () => {
    const sample = textSamples[0]; // Använd första textexemplet för lasttestning
    const promises = Array(10).fill(0).map(() => 
      analysisService.analyzeIngredients(sample.ingredients)
    );
    
    return await Promise.all(promises);
  });
  
  results.push({
    test: 'Gemini Load Test (10 parallel requests)',
    provider: 'Gemini',
    executionTime: loadTestResults.executionTime,
    averageTimePerRequest: loadTestResults.executionTime / 10,
    concurrentRequests: 10
  });
  
  // Generera testrapport
  return generateReport(results);
}

// Kör testerna om filen körs direkt
if (require.main === module) {
  runPerformanceTests()
    .then(() => process.exit(0))
    .catch(error => {
      console.error('Performance tests failed:', error);
      process.exit(1);
    });
}

export { runPerformanceTests, timeExecution, generateReport };
```

### 2. Skapa testdata för prestandatester

Skapa datastrukturer för testning:

```typescript
// src/tests/performance/data/text_samples.json
[
  {
    "name": "Simple Vegan List",
    "ingredients": ["Vatten", "Socker", "Salt", "Vetemjöl", "Jäst", "Vegetabilisk olja"],
    "complexity": "low"
  },
  {
    "name": "Medium Non-Vegan List",
    "ingredients": [
      "Vetemjöl", "Smör", "Socker", "Ägg", "Mjölkpulver", 
      "Bakpulver", "Salt", "Vassle", "Arom", "Vanilj"
    ],
    "complexity": "medium"
  },
  {
    "name": "Complex Mixed List",
    "ingredients": [
      "Vatten", "Socker", "Vetemjöl", "Modifierad stärkelse", "E471", 
      "Stabiliseringsmedel (E412, E410, E407)", "Surhetsreglerande medel (E330, E332)", 
      "Aromer", "Färgämnen (E160a, E120)", "Konserveringsmedel (E202)", 
      "Vitaminer (A, D, E, C)", "Naturliga aromer", "Lecitin (E322)", 
      "Kan innehålla spår av mjölk, ägg och nötter"
    ],
    "complexity": "high"
  },
  {
    "name": "Foreign Language List",
    "ingredients": [
      "Water", "Sugar", "Wheat flour", "Modified starch", "E471", 
      "Stabilizers (E412, E410, E407)", "Acidity regulators (E330, E332)", 
      "Flavorings", "Colorants (E160a, E120)", "Preservatives (E202)", 
      "Vitamins (A, D, E, C)", "Natural flavors", "Lecithin (E322)", 
      "May contain traces of milk, eggs and nuts"
    ],
    "complexity": "medium"
  },
  {
    "name": "Challenging List with Ambiguous Ingredients",
    "ingredients": [
      "Vatten", "Socker", "Vetemjöl", "Naturliga aromer", "E471", 
      "D-vitamin", "Karmin", "Lecitin", "Glycerol", "Vasslepulver",
      "Modifierad stärkelse", "Maltodextrin", "Enzymer", "Antioxidationsmedel",
      "Ytbehandlingsmedel", "Naturliga färgämnen", "Gelatin", "Arom"
    ],
    "complexity": "high"
  }
]
```

```typescript
// src/tests/performance/data/image_paths.json
[
  {
    "name": "Clear Package Image",
    "path": "src/tests/performance/data/images/clear_package.jpg",
    "complexity": "low"
  },
  {
    "name": "Blurry Package Image",
    "path": "src/tests/performance/data/images/blurry_package.jpg",
    "complexity": "medium"
  },
  {
    "name": "Small Text Image",
    "path": "src/tests/performance/data/images/small_text.jpg",
    "complexity": "high"
  },
  {
    "name": "Curved Surface Image",
    "path": "src/tests/performance/data/images/curved_surface.jpg",
    "complexity": "high"
  },
  {
    "name": "Low Light Image",
    "path": "src/tests/performance/data/images/low_light.jpg",
    "complexity": "high"
  }
]
```

```typescript
// src/tests/performance/data/video_paths.json
[
  {
    "name": "Short Product Scan",
    "path": "src/tests/performance/data/videos/short_scan.mp4",
    "duration": 3,
    "complexity": "low"
  },
  {
    "name": "Medium Curved Product Scan",
    "path": "src/tests/performance/data/videos/curved_scan.mp4",
    "duration": 5,
    "complexity": "medium"
  },
  {
    "name": "Long Complex Product Scan",
    "path": "src/tests/performance/data/videos/complex_scan.mp4",
    "duration": 10,
    "complexity": "high"
  }
]
```

### 3. Skapa prestandamätningsverktyg för frontend-appen

```typescript
// app/utils/performanceMonitor.ts
import AsyncStorage from '@react-native-async-storage/async-storage';

export interface PerformanceMetric {
  timestamp: number;
  actionName: string;
  startTime: number;
  endTime: number;
  duration: number;
  success: boolean;
  metadata?: Record<string, any>;
}

class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private readonly STORAGE_KEY = 'KOALENS_PERFORMANCE_METRICS';
  private flushScheduled = false;
  
  /**
   * Starta mätning av en operation
   */
  startMeasure(actionName: string, metadata?: Record<string, any>): string {
    const id = `${actionName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const metric: PerformanceMetric = {
      timestamp: Date.now(),
      actionName,
      startTime: performance.now(),
      endTime: 0,
      duration: 0,
      success: false,
      metadata
    };
    
    // Lagra metriken i minnet
    this.metrics.push(metric);
    return id;
  }
  
  /**
   * Avsluta mätning av en operation
   */
  endMeasure(actionName: string, success: boolean = true, metadata?: Record<string, any>): number {
    const endTime = performance.now();
    
    // Hitta den senaste metriken med matchande actionName
    const metricIndex = this.metrics.findIndex(
      metric => metric.actionName === actionName && metric.endTime === 0
    );
    
    if (metricIndex >= 0) {
      const metric = this.metrics[metricIndex];
      metric.endTime = endTime;
      metric.duration = endTime - metric.startTime;
      metric.success = success;
      
      // Uppdatera metadata om det finns
      if (metadata) {
        metric.metadata = { ...metric.metadata, ...metadata };
      }
      
      // Schemalägg flush till AsyncStorage om det inte redan är schemalagt
      if (!this.flushScheduled) {
        this.flushScheduled = true;
        setTimeout(() => this.flush(), 5000);
      }
      
      return metric.duration;
    }
    
    console.warn(`No matching performance metric found for action: ${actionName}`);
    return 0;
  }
  
  /**
   * Mät en operation med en callback
   */
  async measure<T>(
    actionName: string, 
    callback: () => Promise<T>, 
    metadata?: Record<string, any>
  ): Promise<T> {
    this.startMeasure(actionName, metadata);
    
    try {
      const result = await callback();
      this.endMeasure(actionName, true, { ...metadata, result: 'success' });
      return result;
    } catch (error) {
      this.endMeasure(actionName, false, { 
        ...metadata, 
        result: 'error', 
        errorMessage: error instanceof Error ? error.message : String(error) 
      });
      throw error;
    }
  }
  
  /**
   * Spara alla mätvärden till AsyncStorage
   */
  private async flush(): Promise<void> {
    this.flushScheduled = false;
    
    if (this.metrics.length === 0) {
      return;
    }
    
    try {
      // Hämta befintliga metrics från AsyncStorage
      const existingMetricsString = await AsyncStorage.getItem(this.STORAGE_KEY);
      const existingMetrics: PerformanceMetric[] = existingMetricsString
        ? JSON.parse(existingMetricsString)
        : [];
      
      // Filtrera ut endast slutförda mätningar
      const completedMetrics = this.metrics.filter(metric => metric.endTime > 0);
      
      // Kombinera befintliga och nya metrics
      const allMetrics = [...existingMetrics, ...completedMetrics];
      
      // Behåll endast de senaste 100 mätningarna för att spara utrymme
      const trimmedMetrics = allMetrics.slice(-100);
      
      // Spara till AsyncStorage
      await AsyncStorage.setItem(this.STORAGE_KEY, JSON.stringify(trimmedMetrics));
      
      // Ta bort slutförda metrics från det aktiva minnet
      this.metrics = this.metrics.filter(metric => metric.endTime === 0);
    } catch (error) {
      console.error('Failed to flush performance metrics:', error);
    }
  }
  
  /**
   * Hämta alla lagrade mätvärden
   */
  async getMetrics(): Promise<PerformanceMetric[]> {
    try {
      const metricsString = await AsyncStorage.getItem(this.STORAGE_KEY);
      return metricsString ? JSON.parse(metricsString) : [];
    } catch (error) {
      console.error('Failed to get performance metrics:', error);
      return [];
    }
  }
  
  /**
   * Hämta sammanfattande statistik
   */
  async getStatistics(): Promise<Record<string, any>> {
    const metrics = await this.getMetrics();
    
    // Gruppera per actionName
    const groupedMetrics: Record<string, PerformanceMetric[]> = {};
    
    metrics.forEach(metric => {
      if (!groupedMetrics[metric.actionName]) {
        groupedMetrics[metric.actionName] = [];
      }
      
      groupedMetrics[metric.actionName].push(metric);
    });
    
    // Beräkna statistik för varje grupp
    const statistics: Record<string, any> = {};
    
    Object.entries(groupedMetrics).forEach(([actionName, actionMetrics]) => {
      const durations = actionMetrics.map(m => m.duration);
      const successCount = actionMetrics.filter(m => m.success).length;
      
      statistics[actionName] = {
        count: actionMetrics.length,
        successRate: (successCount / actionMetrics.length) * 100,
        averageDuration: durations.reduce((sum, d) => sum + d, 0) / durations.length,
        minDuration: Math.min(...durations),
        maxDuration: Math.max(...durations),
        p90Duration: this.calculatePercentile(durations, 90)
      };
    });
    
    return statistics;
  }
  
  /**
   * Rensa alla lagrade mätvärden
   */
  async clearMetrics(): Promise<void> {
    try {
      await AsyncStorage.removeItem(this.STORAGE_KEY);
      this.metrics = [];
    } catch (error) {
      console.error('Failed to clear performance metrics:', error);
    }
  }
  
  /**
   * Beräkna percentil för en array av värden
   */
  private calculatePercentile(values: number[], percentile: number): number {
    if (values.length === 0) return 0;
    
    // Sortera värdena
    const sortedValues = [...values].sort((a, b) => a - b);
    
    // Beräkna index för percentilen
    const index = Math.ceil((percentile / 100) * sortedValues.length) - 1;
    
    return sortedValues[index];
  }
}

// Exportera en singleton-instans
export default new PerformanceMonitor();
```

### 4. Integrera prestandamätning i frontend-skanningsprocess

Uppdatera skannningsprocessen för att mäta prestanda:

```typescript
// app/(tabs)/(scan)/camera.tsx (utdrag)
import performanceMonitor from '../../../utils/performanceMonitor';

// I kamerakomponenten
const capturePhoto = async () => {
  try {
    if (camera.current && !isCapturing) {
      setIsCapturing(true);
      
      // Starta prestandamätning
      performanceMonitor.startMeasure('camera_capture', { 
        device: device?.name,
        resolution: `${device?.formats[0]?.videoWidth}x${device?.formats[0]?.videoHeight}`
      });
      
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      
      const photo = await camera.current.takePhoto({
        flash: 'off',
        enableShutterSound: true
      });
      
      // Avsluta prestandamätning för kamerafångst
      performanceMonitor.endMeasure('camera_capture', true, {
        photoPath: photo.path,
        photoSize: await RNFS.stat(photo.path).then(stat => stat.size)
      });
      
      // Starta mätning för navigering till crop-skärm
      performanceMonitor.startMeasure('navigation_to_crop');
      
      router.replace({
        pathname: '/(tabs)/(scan)/crop',
        params: { photoPath: photo.path }
      });
      
      // Avsluta mätning i onMount i crop-skärmen
    }
  } catch (error) {
    // Avsluta mätning vid fel
    performanceMonitor.endMeasure('camera_capture', false, { 
      error: error instanceof Error ? error.message : String(error)
    });
    
    console.error('Failed to take photo:', error);
    // ... resten av felhanteringen
  }
};
```

```typescript
// app/(tabs)/(scan)/crop.tsx (utdrag)
import performanceMonitor from '../../../utils/performanceMonitor';

// I useEffect för crop-skärmen
useEffect(() => {
  // Avsluta navigation mätning från kameraskärmen
  performanceMonitor.endMeasure('navigation_to_crop');
  
  // ... resten av koden
  
  // Starta mätning av bildbeskärning
  performanceMonitor.startMeasure('image_cropping', {
    originalImagePath: photoPath
  });
  
  // Beskärningsprocessen fortsätter...
}, []);

// I handleCrop-funktionen
const croppedImage = await ImageCropPicker.openCropper({
  // ... options ...
});

// Mät analysprocessen
performanceMonitor.endMeasure('image_cropping', true, {
  croppedImagePath: croppedImage.path,
  croppedImageSize: await RNFS.stat(croppedImage.path).then(stat => stat.size),
  width: croppedImage.width,
  height: croppedImage.height
});

// Starta mätning av bildanalys
performanceMonitor.startMeasure('image_analysis');

// ... starta analysen ...
```

```typescript
// app/(tabs)/(scan)/result.tsx (utdrag)
import performanceMonitor from '../../../utils/performanceMonitor';

// I useEffect när resultaten tas emot
useEffect(() => {
  // Avsluta mätningen av bildanalys
  if (product && !loading) {
    performanceMonitor.endMeasure('image_analysis', true, {
      imageAnalysisSuccess: true,
      isVegan: product.analysis.isVegan,
      confidence: product.analysis.confidence,
      ingredientCount: product.ingredients.length
    });
  } else if (error) {
    performanceMonitor.endMeasure('image_analysis', false, {
      imageAnalysisSuccess: false,
      error: error.message
    });
  }
}, [product, loading, error]);
```

### 5. Konfigurera prestandatest med automatiserade testfall

Skapa skript för att köra automatiserade prestandatest:

```bash
#!/bin/bash
# run_performance_tests.sh

# Definiera antalet testrundor
ROUNDS=5

# Förbered miljön
echo "Preparing test environment..."
npm run build

# Skapa resultatmapp
RESULT_DIR="performance_results_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$RESULT_DIR"

echo "Running $ROUNDS rounds of performance tests..."

# Kör flera rundor av tester
for (( i=1; i<=$ROUNDS; i++ ))
do
  echo "Starting test round $i of $ROUNDS..."
  
  # Kör testet och spara resultaterna
  RESULT_FILE="$RESULT_DIR/round_${i}_results.json"
  
  NODE_ENV=test node dist/tests/performance/testPerformance.js > "$RESULT_FILE"
  
  echo "Completed test round $i, results saved to $RESULT_FILE"
  
  # Vänta lite mellan tester för att undvika rate-limiting
  if [ $i -lt $ROUNDS ]; then
    echo "Waiting 30 seconds before next round..."
    sleep 30
  fi
done

# Analysera resultaten
echo "Analyzing results..."

# Beräkna genomsnittlig tid för varje test
node -e "
const fs = require('fs');
const path = require('path');

const resultDir = '$RESULT_DIR';
const files = fs.readdirSync(resultDir).filter(f => f.endsWith('_results.json'));

// Samla test data
const allResults = {};

files.forEach(file => {
  try {
    const data = JSON.parse(fs.readFileSync(path.join(resultDir, file), 'utf8'));
    data.results.forEach(result => {
      const testKey = \`\${result.provider} - \${result.test}\`;
      if (!allResults[testKey]) {
        allResults[testKey] = {
          times: [],
          provider: result.provider,
          test: result.test
        };
      }
      allResults[testKey].times.push(result.executionTime);
    });
  } catch (e) {
    console.error(\`Error processing \${file}: \${e.message}\`);
  }
});

// Beräkna statistik
const summaryResults = Object.entries(allResults).map(([key, data]) => {
  const times = data.times;
  const avg = times.reduce((sum, time) => sum + time, 0) / times.length;
  const min = Math.min(...times);
  const max = Math.max(...times);
  const sorted = [...times].sort((a, b) => a - b);
  const median = sorted[Math.floor(sorted.length / 2)];
  
  return {
    test: data.test,
    provider: data.provider,
    average: avg.toFixed(2),
    median: median.toFixed(2),
    min: min.toFixed(2),
    max: max.toFixed(2),
    samples: times.length
  };
});

// Skapa jämförelser mellan Gemini och Claude (om tillgängligt)
const comparisons = [];

const testNames = [...new Set(summaryResults.map(r => r.test.replace(/(Gemini|Claude) /, '')))];

testNames.forEach(testName => {
  const geminiResult = summaryResults.find(r => r.provider === 'Gemini' && r.test.includes(testName));
  const claudeResult = summaryResults.find(r => r.provider === 'Claude' && r.test.includes(testName));
  
  if (geminiResult && claudeResult) {
    const geminiAvg = parseFloat(geminiResult.average);
    const claudeAvg = parseFloat(claudeResult.average);
    const diff = ((geminiAvg - claudeAvg) / claudeAvg * 100).toFixed(2);
    
    comparisons.push({
      test: testName,
      geminiAvg: geminiAvg.toFixed(2),
      claudeAvg: claudeAvg.toFixed(2),
      diff: \`\${diff}%\`,
      faster: diff < 0 ? 'Gemini' : 'Claude'
    });
  }
});

// Spara sammanfattning
const summaryFile = path.join(resultDir, 'summary.json');
fs.writeFileSync(
  summaryFile, 
  JSON.stringify({
    timestamp: new Date().toISOString(),
    tests: summaryResults,
    comparisons
  }, null, 2)
);

// Visa resultaten
console.log('\\n=== Test Results Summary ===');
console.table(summaryResults);

if (comparisons.length > 0) {
  console.log('\\n=== Gemini vs Claude Comparison ===');
  console.table(comparisons);
}

console.log(\`\\nDetailed summary saved to \${summaryFile}\`);
"

echo "Performance testing completed!"
```

### 6. Mäta och optimera nätverkstrafik

Skapa ett verktyg för att mäta API-anropens storlek för att optimera nätverkstrafik:

```typescript
// src/utils/networkTrafficMonitor.ts
import fs from 'fs';
import path from 'path';

interface NetworkRequest {
  timestamp: number;
  url: string;
  method: string;
  requestSize: number;
  responseSize: number;
  duration: number;
  status: number;
  cached: boolean;
}

class NetworkTrafficMonitor {
  private requests: NetworkRequest[] = [];
  private readonly logDir: string;
  
  constructor() {
    this.logDir = path.join(__dirname, '../../logs/network');
    
    // Skapa loggmapp om den inte finns
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }
  
  /**
   * Logga en nätverksbegäran
   */
  logRequest(request: NetworkRequest): void {
    this.requests.push(request);
    
    // Om vi har många förfrågningar, spara till disk och rensa
    if (this.requests.length >= 100) {
      this.saveRequestsToFile();
      this.requests = [];
    }
  }
  
  /**
   * Beräkna storlek på request body
   */
  calculateRequestSize(body: any): number {
    if (!body) return 0;
    
    if (typeof body === 'string') {
      return Buffer.byteLength(body, 'utf8');
    }
    
    if (Buffer.isBuffer(body)) {
      return body.length;
    }
    
    try {
      const jsonString = JSON.stringify(body);
      return Buffer.byteLength(jsonString, 'utf8');
    } catch (error) {
      console.warn('Failed to calculate request size:', error);
      return 0;
    }
  }
  
  /**
   * Beräkna storlek på response body
   */
  calculateResponseSize(body: any): number {
    return this.calculateRequestSize(body);
  }
  
  /**
   * Spara förfrågningar till loggfil
   */
  saveRequestsToFile(): void {
    if (this.requests.length === 0) return;
    
    const fileName = `network_log_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    const filePath = path.join(this.logDir, fileName);
    
    try {
      fs.writeFileSync(filePath, JSON.stringify(this.requests, null, 2));
      console.log(`Network traffic log saved to ${filePath}`);
    } catch (error) {
      console.error('Failed to save network traffic log:', error);
    }
  }
  
  /**
   * Hämta nätverksstatistik
   */
  getStatistics(): Record<string, any> {
    if (this.requests.length === 0) {
      return { totalRequests: 0 };
    }
    
    // Beräkna total trafik
    const totalRequestSize = this.requests.reduce((sum, req) => sum + req.requestSize, 0);
    const totalResponseSize = this.requests.reduce((sum, req) => sum + req.responseSize, 0);
    const totalDuration = this.requests.reduce((sum, req) => sum + req.duration, 0);
    
    // Gruppera efter URL
    const urlStats: Record<string, any> = {};
    
    this.requests.forEach(req => {
      // Extrahera basvägen från URL
      const urlPath = new URL(req.url).pathname;
      
      if (!urlStats[urlPath]) {
        urlStats[urlPath] = {
          count: 0,
          totalRequestSize: 0,
          totalResponseSize: 0,
          totalDuration: 0,
          statuses: {}
        };
      }
      
      urlStats[urlPath].count++;
      urlStats[urlPath].totalRequestSize += req.requestSize;
      urlStats[urlPath].totalResponseSize += req.responseSize;
      urlStats[urlPath].totalDuration += req.duration;
      
      // Räkna HTTP-statuskoder
      const status = req.status.toString();
      urlStats[urlPath].statuses[status] = (urlStats[urlPath].statuses[status] || 0) + 1;
    });
    
    // Beräkna genomsnitt
    Object.keys(urlStats).forEach(url => {
      const stats = urlStats[url];
      stats.avgRequestSize = stats.totalRequestSize / stats.count;
      stats.avgResponseSize = stats.totalResponseSize / stats.count;
      stats.avgDuration = stats.totalDuration / stats.count;
    });
    
    return {
      totalRequests: this.requests.length,
      totalRequestSize,
      totalResponseSize,
      totalNetworkTraffic: totalRequestSize + totalResponseSize,
      totalDuration,
      avgRequestSize: totalRequestSize / this.requests.length,
      avgResponseSize: totalResponseSize / this.requests.length,
      avgDuration: totalDuration / this.requests.length,
      urlStats
    };
  }
  
  /**
   * Rensa alla loggade förfrågningar
   */
  clearRequests(): void {
    this.requests = [];
  }
}

// Exportera en singleton-instans
export default new NetworkTrafficMonitor();
```

### 7. Konfigurera prestandaövervakning i produktionsmiljö

Skapa konfiguration för att mäta prestanda i produktionsmiljön:

```typescript
// src/middleware/performanceMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import fs from 'fs';
import path from 'path';

export function performanceMiddleware(req: Request, res: Response, next: NextFunction) {
  // Spara starttiden
  const startTime = process.hrtime();
  
  // Spara den ursprungliga end-metoden för response
  const originalEnd = res.end;
  
  // Beräkna uppskattad request-storlek
  const requestSize = Buffer.byteLength(JSON.stringify(req.body || {}), 'utf8');
  
  // Skapa array för att lagra response body chunks
  const chunks: Buffer[] = [];
  
  // Ersätt write-metoden för att fånga response data
  const originalWrite = res.write;
  res.write = function(chunk: any, ...args: any[]) {
    if (chunk) {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    }
    return originalWrite.apply(res, [chunk, ...args] as any);
  };
  
  // Ersätt end-metoden för att logga prestanda
  res.end = function(chunk: any, ...args: any[]) {
    // Om det finns ett chunk, lägg till det
    if (chunk) {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    }
    
    // Beräkna exekveringstid
    const hrTime = process.hrtime(startTime);
    const duration = hrTime[0] * 1000 + hrTime[1] / 1000000; // ms
    
    // Beräkna response-storlek
    const responseSize = chunks.reduce((total, chunk) => total + chunk.length, 0);
    
    // Logga prestandadata
    const performanceData = {
      timestamp: new Date().toISOString(),
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: duration,
      requestSize: requestSize,
      responseSize: responseSize,
      userAgent: req.headers['user-agent'] || 'unknown'
    };
    
    // Skriv till logfil asynkront
    const logDir = path.join(__dirname, '../../logs/performance');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    const logFile = path.join(logDir, `performance_${new Date().toISOString().split('T')[0]}.log`);
    
    fs.appendFile(
      logFile, 
      JSON.stringify(performanceData) + '\n', 
      { encoding: 'utf8' }, 
      (err) => {
        if (err) {
          console.error('Failed to write performance log:', err);
        }
      }
    );
    
    // Lägg till prestandadata i en custom header om det är i utvecklingsmiljön
    if (process.env.NODE_ENV === 'development') {
      res.setHeader('X-Performance-Data', JSON.stringify({
        duration: duration,
        requestSize: requestSize,
        responseSize: responseSize
      }));
    }
    
    // Anropa den ursprungliga end-metoden
    return originalEnd.apply(res, [chunk, ...args] as any);
  };
  
  next();
}
```

Lägg till middleware i app.ts:

```typescript
// src/app.ts
import express from 'express';
import { performanceMiddleware } from './middleware/performanceMiddleware';

const app = express();

// Lägg till performance middleware innan andra middleware
app.use(performanceMiddleware);

// ... resten av appens konfiguration
```

### 8. Skapa visualiseringsverktyg för prestandamätningar

Skapa ett enkelt webbaserat visualiseringsverktyg för prestandamätningar:

```typescript
// src/routes/admin/performanceRoutes.ts
import { Router } from 'express';
import fs from 'fs';
import path from 'path';

const router = Router();

// Visa prestanda dashboard
router.get('/performance', (req, res) => {
  res.render('performance-dashboard', {
    title: 'KoaLens Performance Dashboard'
  });
});

// API för att hämta prestandadata
router.get('/api/performance', (req, res) => {
  try {
    const logDir = path.join(__dirname, '../../../logs/performance');
    
    // Kontrollera att katalogen finns
    if (!fs.existsSync(logDir)) {
      return res.json({ error: 'No performance logs found' });
    }
    
    // Hämta alla logfiler
    const logFiles = fs.readdirSync(logDir)
      .filter(file => file.startsWith('performance_') && file.endsWith('.log'))
      .sort((a, b) => b.localeCompare(a)); // Nyaste först
    
    // Begränsa till de senaste filerna om inget datumfilter anges
    const maxFiles = 7;
    const files = req.query.date 
      ? logFiles.filter(file => file.includes(req.query.date as string))
      : logFiles.slice(0, maxFiles);
    
    // Läs och parsa alla loggfiler
    const data: any[] = [];
    
    files.forEach(file => {
      const filePath = path.join(logDir, file);
      const content = fs.readFileSync(filePath, 'utf8');
      
      content.split('\n')
        .filter(line => line.trim() !== '')
        .forEach(line => {
          try {
            const logEntry = JSON.parse(line);
            data.push(logEntry);
          } catch (e) {
            console.error(`Error parsing log line: ${line}`);
          }
        });
    });
    
    // Gruppera och analysera data
    const endpointStats: Record<string, any> = {};
    
    data.forEach(entry => {
      // Förenkla URL genom att ta bort queryparametrar
      const url = entry.url.split('?')[0];
      
      if (!endpointStats[url]) {
        endpointStats[url] = {
          count: 0,
          totalDuration: 0,
          totalRequestSize: 0,
          totalResponseSize: 0,
          durations: []
        };
      }
      
      endpointStats[url].count++;
      endpointStats[url].totalDuration += entry.duration;
      endpointStats[url].totalRequestSize += entry.requestSize;
      endpointStats[url].totalResponseSize += entry.responseSize;
      endpointStats[url].durations.push(entry.duration);
    });
    
    // Beräkna statistik för varje endpoint
    Object.keys(endpointStats).forEach(url => {
      const stats = endpointStats[url];
      const durations = stats.durations.sort((a: number, b: number) => a - b);
      
      stats.avgDuration = stats.totalDuration / stats.count;
      stats.avgRequestSize = stats.totalRequestSize / stats.count;
      stats.avgResponseSize = stats.totalResponseSize / stats.count;
      stats.medianDuration = durations[Math.floor(durations.length / 2)];
      stats.p95Duration = durations[Math.floor(durations.length * 0.95)];
      stats.minDuration = durations[0];
      stats.maxDuration = durations[durations.length - 1];
      
      // Ta bort den råa durationsarrayen för att spara minne
      delete stats.durations;
    });
    
    // Skapa tidsserier för visualisering
    const timeSeriesData = data
      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())
      .map(entry => ({
        timestamp: entry.timestamp,
        url: entry.url.split('?')[0],
        duration: entry.duration,
        statusCode: entry.statusCode
      }));
    
    return res.json({
      totalRequests: data.length,
      endpointStats,
      timeSeriesData
    });
  } catch (error: any) {
    return res.status(500).json({
      error: `Failed to process performance logs: ${error.message}`
    });
  }
});

export default router;
```

Skapa en enkel HTML-mall för dashboarden:

```html
<!-- src/views/performance-dashboard.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %></title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <style>
    .chart-container {
      height: 300px;
      margin-bottom: 30px;
    }
  </style>
</head>
<body>
  <div class="container mt-4">
    <h1><%= title %></h1>
    
    <div class="row mt-4">
      <div class="col-md-6">
        <div class="card">
          <div class="card-header">
            <h5>Request Duration Over Time</h5>
          </div>
          <div class="card-body">
            <div class="chart-container">
              <canvas id="durationChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      
      <div class="col-md-6">
        <div class="card">
          <div class="card-header">
            <h5>Endpoint Performance</h5>
          </div>
          <div class="card-body">
            <div class="chart-container">
              <canvas id="endpointChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="row mt-4">
      <div class="col-md-12">
        <div class="card">
          <div class="card-header">
            <h5>Endpoint Statistics</h5>
          </div>
          <div class="card-body">
            <table class="table table-striped">
              <thead>
                <tr>
                  <th>Endpoint</th>
                  <th>Count</th>
                  <th>Avg Duration (ms)</th>
                  <th>P95 Duration (ms)</th>
                  <th>Avg Request Size (bytes)</th>
                  <th>Avg Response Size (bytes)</th>
                </tr>
              </thead>
              <tbody id="statsTable">
                <tr>
                  <td colspan="6" class="text-center">Loading data...</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Hämta prestandadata från API
    async function fetchPerformanceData() {
      try {
        const response = await fetch('/admin/api/performance');
        return await response.json();
      } catch (error) {
        console.error('Failed to fetch performance data:', error);
        return null;
      }
    }
    
    // Rendera diagram
    async function renderCharts() {
      const data = await fetchPerformanceData();
      
      if (!data || data.error) {
        alert(`Error: ${data?.error || 'Failed to load performance data'}`);
        return;
      }
      
      // Duration Over Time Chart
      const timeCtx = document.getElementById('durationChart').getContext('2d');
      
      // Gruppera data per minut för tydligare visualisering
      const timeData = data.timeSeriesData.reduce((groups, entry) => {
        const timestamp = new Date(entry.timestamp);
        const minuteKey = new Date(
          timestamp.getFullYear(), 
          timestamp.getMonth(), 
          timestamp.getDate(), 
          timestamp.getHours(), 
          timestamp.getMinutes()
        ).toISOString();
        
        if (!groups[minuteKey]) {
          groups[minuteKey] = {
            durations: [],
            url: entry.url
          };
        }
        
        groups[minuteKey].durations.push(entry.duration);
        
        return groups;
      }, {});
      
      const timeLabels = Object.keys(timeData).map(key => {
        const date = new Date(key);
        return `${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
      });
      
      const avgDurations = Object.values(timeData).map((group: any) => {
        const sum = group.durations.reduce((a: number, b: number) => a + b, 0);
        return sum / group.durations.length;
      });
      
      new Chart(timeCtx, {
        type: 'line',
        data: {
          labels: timeLabels,
          datasets: [{
            label: 'Average Duration (ms)',
            data: avgDurations,
            borderColor: 'rgb(75, 192, 192)',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
      
      // Endpoint Performance Chart
      const endpointCtx = document.getElementById('endpointChart').getContext('2d');
      
      const endpoints = Object.keys(data.endpointStats);
      const avgDurationByEndpoint = endpoints.map(endpoint => data.endpointStats[endpoint].avgDuration);
      
      new Chart(endpointCtx, {
        type: 'bar',
        data: {
          labels: endpoints,
          datasets: [{
            label: 'Average Duration (ms)',
            data: avgDurationByEndpoint,
            backgroundColor: 'rgba(54, 162, 235, 0.5)',
            borderColor: 'rgb(54, 162, 235)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
      
      // Populate Statistics Table
      const statsTable = document.getElementById('statsTable');
      statsTable.innerHTML = '';
      
      endpoints.forEach(endpoint => {
        const stats = data.endpointStats[endpoint];
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${endpoint}</td>
          <td>${stats.count}</td>
          <td>${stats.avgDuration.toFixed(2)}</td>
          <td>${stats.p95Duration.toFixed(2)}</td>
          <td>${stats.avgRequestSize.toFixed(0)}</td>
          <td>${stats.avgResponseSize.toFixed(0)}</td>
        `;
        
        statsTable.appendChild(row);
      });
    }
    
    // Starta rendereringen när sidan laddas
    document.addEventListener('DOMContentLoaded', renderCharts);
  </script>
</body>
</html>
```

## Verifiering

För att verifiera prestandan:

1. Kör det automatiserade prestandatestet:
```bash
chmod +x run_performance_tests.sh
./run_performance_tests.sh
```

2. Inspektera resultaten i testerna:
```bash
cat performance_results_*/summary.json
```

3. Kontrollera belastningen på produktionsmiljön genom att öppna admin-dashboarden på:
```
https://din-backend.fly.dev/admin/performance
```

4. Verifiera mängden nätverkstrafik genom att inspektera nätverksloggarna:
```bash
cat logs/network/network_log_*.json | jq '.[] | {url, requestSize, responseSize}'
```

5. Kontrollera frontend-prestandamätningarna:
```javascript
// I utvecklingskonsolen på Din KoaLens app
import performanceMonitor from './utils/performanceMonitor';
performanceMonitor.getStatistics().then(console.table);
```

## Felsökning

### Problem: Långsam bildanalys
**Lösning**: Kontrollera bildkompression och optimera upplösning:
```typescript
// Optimera bildstorlek innan analys
async function optimizeImage(imagePath: string): Promise<string> {
  const optimizedImagePath = `${imagePath}_optimized.jpg`;
  
  await sharp(imagePath)
    .resize({ width: 1200, height: 1200, fit: 'inside' })
    .jpeg({ quality: 85 })
    .toFile(optimizedImagePath);
  
  return optimizedImagePath;
}
```

### Problem: Höga latenser i API-anrop
**Lösning**: Implementera caching för ofta förekommande förfrågningar:
```typescript
// Implementera ett enkelt caching-system
const responseCache = new Map();

app.use((req, res, next) => {
  // Skapa en cache-nyckel baserad på metod och URL
  const cacheKey = `${req.method}:${req.originalUrl}`;
  
  // Kontrollera endast GET-requests
  if (req.method === 'GET' && responseCache.has(cacheKey)) {
    // Hämta cache-träff och datum
    const { data, timestamp } = responseCache.get(cacheKey);
    
    // Kontrollera om cachen är färsk (max 5 minuter gammal)
    const isStale = Date.now() - timestamp > 5 * 60 * 1000;
    
    if (!isStale) {
      // Sätt header som indikerar cache-träff
      res.setHeader('X-Cache', 'HIT');
      return res.json(data);
    }
  }
  
  // Spara ursprunglig json-metod
  const originalJson = res.json;
  
  // Överskrid json-metoden för att spara resultatet
  res.json = function(data) {
    // Cacha endast framgångsrika GET-requests
    if (req.method === 'GET' && res.statusCode >= 200 && res.statusCode < 300) {
      const cacheKey = `${req.method}:${req.originalUrl}`;
      responseCache.set(cacheKey, {
        data,
        timestamp: Date.now()
      });
    }
    
    // Anropa ursprunglig json-metod
    return originalJson.call(this, data);
  };
  
  next();
});
```

### Problem: Höga minnesanvändning under videoanalys
**Lösning**: Implementera chunked-processing och förbättra minneshantering:
```typescript
// Implementera stegvis bearbetning
async function processVideoInChunks(videoPath: string): Promise<string[]> {
  const results = [];
  
  // Extrahera frames vid jämna intervall
  const frameRate = 1; // En frame per sekund
  const maxFrames = 10; // Begränsa antalet frames
  
  // Använd ffmpeg för att extrahera frames
  const frames = await extractFrames(videoPath, frameRate, maxFrames);
  
  // Bearbeta var frame för sig
  for (const frame of frames) {
    const result = await analyzeImage(frame);
    results.push(result);
    
    // Rensa minnet genom att ta bort den bearbetade framen
    await fs.promises.unlink(frame).catch(() => {});
  }
  
  return results;
}
```

## Nästa steg

Efter att ha verifierat prestandan bör du identifiera flaskhalsar och områden för optimering. De vanligaste områdena för optimering inkluderar:

1. Bildkompression innan analys
2. Parallellisering av API-anrop
3. Implementera caching för vanliga ingredienslistor
4. Optimera API-gränssnittet för att minska datamängden
5. Optimera prompt-längden för att minska tokenanvändningen

Fortsätt sedan till nästa steg för att implementera en robust felhantering som kompletterar prestandaförbättringarna.

## Referenser
- [Google Gemini API Performance Best Practices](https://ai.google.dev/docs/performance_best_practices)
- [Node.js Performance Measurement](https://nodejs.org/api/perf_hooks.html)
- [React Native Performance Monitoring](https://reactnative.dev/docs/performance)
- [Express.js Performance Tips](https://expressjs.com/en/advanced/best-practice-performance.html)
- [Optimizing Network Requests in Mobile Apps](https://developer.mozilla.org/en-US/docs/Web/Performance/Optimizing_network_requests)

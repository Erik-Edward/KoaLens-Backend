# Steg 19: Iterativ förbättring

## Mål och syfte
Etablera en systematisk process för kontinuerlig övervakning, utvärdering och förbättring av Gemini-implementationen i KoaLens. Detta steg säkerställer att analysnoggrannheten ökar över tid, att prestandan optimeras, och att nya funktioner kan introduceras på ett strukturerat sätt. Iterativ förbättring är nyckeln till att maximera värdet av Gemini 2.5 Pro och hålla appen relevant när både teknologin och användarnas förväntningar utvecklas.

## Förutsättningar
- Framgångsrik driftsättning i produktion (steg 17)
- Etablerad övervakning och loggning (steg 18)
- Dedikerad tid och resurser för kontinuerliga förbättringar
- Etablerade kanaler för användarfeedback
- Tillgång till analysverktyg för prestanda och användningsmönster

## Detaljerade instruktioner

### 1. Etablera en datainsamlings- och analysstrategi

Skapa en process för systematisk insamling och analys av data om Gemini-implementationens prestanda:

```typescript
// src/services/analyticsService.ts
import { AnalysisResult } from '../utils/outputParser';
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';

interface AnalysisMetrics {
  requestId: string;
  userId?: string;
  timestamp: string;
  provider: 'gemini' | 'claude';
  contentType: 'text' | 'image' | 'video';
  responseTimeMs: number;
  isVegan: boolean | null;
  confidence: number;
  ingredientCount: number;
  nonVeganCount: number;
  tokenCount?: number;
  modelVersion: string;
  promptTemplate: string;
}

export class AnalyticsService {
  /**
   * Spara analyssmetrik för uppföljning och förbättring
   */
  async trackAnalysis(metrics: Partial<AnalysisMetrics>): Promise<void> {
    try {
      const fullMetrics: AnalysisMetrics = {
        requestId: metrics.requestId || crypto.randomUUID(),
        timestamp: metrics.timestamp || new Date().toISOString(),
        provider: metrics.provider || 'gemini',
        contentType: metrics.contentType || 'text',
        responseTimeMs: metrics.responseTimeMs || 0,
        isVegan: metrics.isVegan || null,
        confidence: metrics.confidence || 0,
        ingredientCount: metrics.ingredientCount || 0,
        nonVeganCount: metrics.nonVeganCount || 0,
        tokenCount: metrics.tokenCount,
        modelVersion: metrics.modelVersion || process.env.GEMINI_MODEL_NAME || 'gemini-2.5-pro',
        promptTemplate: metrics.promptTemplate || 'default',
        userId: metrics.userId
      };
      
      // Logga metrik för realtidsövervakning
      logger.info('Analysis metrics', { metrics: fullMetrics });
      
      // Spara till databas för långtidsanalys
      await supabase
        .from('analysis_metrics')
        .insert(fullMetrics);
        
    } catch (error: any) {
      logger.error('Failed to track analysis metrics', { error: error.message });
    }
  }
  
  /**
   * Spåra användarproblem eller feedback
   */
  async trackIssue(userId: string, analysisId: string, issue: string, details?: any): Promise<void> {
    try {
      await supabase
        .from('analysis_issues')
        .insert({
          user_id: userId,
          analysis_id: analysisId,
          issue_type: issue,
          details: details,
          timestamp: new Date().toISOString(),
          status: 'open'
        });
      
      logger.info('User issue reported', { userId, analysisId, issue });
    } catch (error: any) {
      logger.error('Failed to track user issue', { error: error.message });
    }
  }
  
  /**
   * Hämta prestanda-statistik för en given period
   */
  async getPerformanceStats(
    provider: 'gemini' | 'claude' | 'all' = 'all', 
    days: number = 7
  ): Promise<any> {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);
      
      let query = supabase
        .from('analysis_metrics')
        .select('*')
        .gte('timestamp', startDate.toISOString());
      
      if (provider !== 'all') {
        query = query.eq('provider', provider);
      }
      
      const { data, error } = await query;
      
      if (error) {
        throw error;
      }
      
      // Beräkna statistik
      const stats = this.calculateStats(data);
      return stats;
    } catch (error: any) {
      logger.error('Failed to get performance stats', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Beräkna statistik från rådata
   */
  private calculateStats(data: any[]): any {
    if (!data || data.length === 0) {
      return {
        totalRequests: 0,
        averageResponseTime: 0,
        accuracyMetrics: {
          veganCorrect: 0,
          nonVeganCorrect: 0,
          uncertainCount: 0,
          accuracy: 0
        }
      };
    }
    
    // Beräkna grundläggande statistik
    const totalRequests = data.length;
    const averageResponseTime = data.reduce((sum, item) => sum + item.responseTimeMs, 0) / totalRequests;
    
    // Gruppera per provider för jämförelse
    const byProvider: { [key: string]: any[] } = {};
    data.forEach(item => {
      if (!byProvider[item.provider]) {
        byProvider[item.provider] = [];
      }
      byProvider[item.provider].push(item);
    });
    
    // För varje provider, beräkna statistik
    const providerStats: { [key: string]: any } = {};
    Object.entries(byProvider).forEach(([provider, items]) => {
      const avgResponseTime = items.reduce((sum, item) => sum + item.responseTimeMs, 0) / items.length;
      const veganCount = items.filter(item => item.isVegan === true).length;
      const nonVeganCount = items.filter(item => item.isVegan === false).length;
      const uncertainCount = items.filter(item => item.isVegan === null).length;
      
      providerStats[provider] = {
        totalRequests: items.length,
        averageResponseTime: avgResponseTime,
        veganCount,
        nonVeganCount,
        uncertainCount,
        percentageOfTotal: (items.length / totalRequests) * 100
      };
    });
    
    return {
      totalRequests,
      averageResponseTime,
      byProvider: providerStats,
      timeRange: {
        start: new Date(Math.min(...data.map(item => new Date(item.timestamp).getTime()))).toISOString(),
        end: new Date(Math.max(...data.map(item => new Date(item.timestamp).getTime()))).toISOString()
      }
    };
  }
}

export default new AnalyticsService();
```

### 2. Implementera en systematisk process för kontinuerlig promptförbättring

Skapa ett system för att iterativt förbättra promptmallar baserat på data:

```typescript
// src/services/promptOptimizationService.ts
import promptManager from '../utils/promptManager';
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';

interface PromptVariant {
  id: string;
  name: string;
  template: string;
  purpose: string;
  createdAt: string;
  successRate?: number;
  averageConfidence?: number;
  averageResponseTime?: number;
  totalUses?: number;
}

export class PromptOptimizationService {
  /**
   * Registrera en ny promptvariant för testning
   */
  async registerPromptVariant(
    name: string, 
    template: string, 
    purpose: string
  ): Promise<string> {
    try {
      const id = crypto.randomUUID();
      const variant: PromptVariant = {
        id,
        name,
        template,
        purpose,
        createdAt: new Date().toISOString()
      };
      
      // Spara i databas
      await supabase
        .from('prompt_variants')
        .insert(variant);
      
      // Lägg till i promptManager för användning
      promptManager.addTemplate(name, template);
      
      logger.info('New prompt variant registered', { name, id });
      return id;
    } catch (error: any) {
      logger.error('Failed to register prompt variant', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Registrera resultat från användning av en promptvariant
   */
  async trackPromptUsage(
    variantId: string, 
    success: boolean, 
    confidence: number, 
    responseTimeMs: number
  ): Promise<void> {
    try {
      await supabase
        .from('prompt_usage')
        .insert({
          variant_id: variantId,
          success,
          confidence,
          response_time_ms: responseTimeMs,
          timestamp: new Date().toISOString()
        });
    } catch (error: any) {
      logger.error('Failed to track prompt usage', { error: error.message });
    }
  }
  
  /**
   * Hämta prestanda för alla promptvarianter
   */
  async getPromptPerformance(): Promise<PromptVariant[]> {
    try {
      // Hämta alla promptvarianter
      const { data: variants, error: variantsError } = await supabase
        .from('prompt_variants')
        .select('*');
      
      if (variantsError) {
        throw variantsError;
      }
      
      // För varje variant, hämta användningsstatistik
      const variantsWithStats = await Promise.all(variants.map(async (variant) => {
        const { data: usage, error: usageError } = await supabase
          .from('prompt_usage')
          .select('*')
          .eq('variant_id', variant.id);
        
        if (usageError) {
          logger.error('Failed to get prompt usage', { error: usageError.message });
          return variant;
        }
        
        if (!usage || usage.length === 0) {
          return variant;
        }
        
        // Beräkna statistik
        const successCount = usage.filter(item => item.success).length;
        const totalUses = usage.length;
        const successRate = totalUses > 0 ? (successCount / totalUses) * 100 : 0;
        const averageConfidence = usage.reduce((sum, item) => sum + item.confidence, 0) / totalUses;
        const averageResponseTime = usage.reduce((sum, item) => sum + item.response_time_ms, 0) / totalUses;
        
        return {
          ...variant,
          successRate,
          averageConfidence,
          averageResponseTime,
          totalUses
        };
      }));
      
      return variantsWithStats;
    } catch (error: any) {
      logger.error('Failed to get prompt performance', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Generera förslag på en förbättrad prompt baserat på befintliga promptar
   */
  async suggestImprovedPrompt(variantId: string): Promise<string> {
    try {
      // Hämta aktuell promptvariant
      const { data: variant, error: variantError } = await supabase
        .from('prompt_variants')
        .select('*')
        .eq('id', variantId)
        .single();
      
      if (variantError) {
        throw variantError;
      }
      
      // Hämta prestanda för promptvarianten
      const { data: usage, error: usageError } = await supabase
        .from('prompt_usage')
        .select('*')
        .eq('variant_id', variantId);
      
      if (usageError) {
        throw usageError;
      }
      
      // Hämta exempel på misslyckade analyser
      const { data: failedAnalyses, error: analysesError } = await supabase
        .from('analysis_metrics')
        .select('*')
        .eq('promptTemplate', variant.name)
        .eq('success', false)
        .limit(5);
      
      if (analysesError) {
        throw analysesError;
      }
      
      // Använd Gemini för att föreslå en förbättrad prompt
      const aiService = await AIServiceFactory.getService();
      
      const prompt = `
      Jag har en promptmall för ingrediensanalys i KoaLens-appen som behöver förbättras.
      
      Aktuell promptmall:
      ${variant.template}
      
      Prestanda:
      - Framgångsfrekvens: ${(usage.filter(item => item.success).length / usage.length) * 100}%
      - Genomsnittlig konfidens: ${usage.reduce((sum, item) => sum + item.confidence, 0) / usage.length}
      - Antal användningar: ${usage.length}
      
      Exempel på misslyckade analyser:
      ${failedAnalyses.map(a => `- Ingredienser: ${a.ingredients?.join(', ')}`).join('\n')}
      
      Baserat på denna information, föreslå en förbättrad promptmall som kan öka precisionen
      och minska antalet osäkra resultat. Behåll samma JSON-outputformat men förbättra
      instruktionerna och kontexten som ges till modellen.
      `;
      
      const result = await aiService.generateContent(prompt);
      return result;
    } catch (error: any) {
      logger.error('Failed to suggest improved prompt', { error: error.message });
      throw error;
    }
  }
}

export default new PromptOptimizationService();
```

### 3. Skapa ett dashboard för att övervaka prestanda

Implementera ett administrativt dashboard för att övervaka och hantera AI-prestanda:

```typescript
// src/routes/adminRoutes.ts
import { Router } from 'express';
import analyticsService from '../services/analyticsService';
import promptOptimizationService from '../services/promptOptimizationService';
import logger from '../utils/logger';

const router = Router();

// Autentiseringsskydd för admin-routes
const authMiddleware = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  if (apiKey !== process.env.ADMIN_API_KEY) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
};

router.use(authMiddleware);

// Hämta övergripande prestanda
router.get('/performance', async (req, res) => {
  try {
    const days = parseInt(req.query.days as string) || 7;
    const provider = req.query.provider as 'gemini' | 'claude' | 'all' || 'all';
    
    const stats = await analyticsService.getPerformanceStats(provider, days);
    return res.json(stats);
  } catch (error: any) {
    logger.error('Failed to get performance stats', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

// Hämta promptprestanda
router.get('/prompts', async (req, res) => {
  try {
    const prompts = await promptOptimizationService.getPromptPerformance();
    return res.json(prompts);
  } catch (error: any) {
    logger.error('Failed to get prompt performance', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

// Skapa en ny promptvariant
router.post('/prompts', async (req, res) => {
  try {
    const { name, template, purpose } = req.body;
    const id = await promptOptimizationService.registerPromptVariant(name, template, purpose);
    return res.json({ id, success: true });
  } catch (error: any) {
    logger.error('Failed to create prompt variant', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

// Få förslag på förbättrad prompt
router.get('/prompts/:id/suggest-improvement', async (req, res) => {
  try {
    const id = req.params.id;
    const suggestion = await promptOptimizationService.suggestImprovedPrompt(id);
    return res.json({ suggestion, success: true });
  } catch (error: any) {
    logger.error('Failed to suggest prompt improvement', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

export default router;
```

### 4. Implementera systematisk A/B-testning

Skapa en struktur för kontinuerlig A/B-testning av olika aspekter av systemet:

```typescript
// src/services/abTestingService.ts
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';

interface Test {
  id: string;
  name: string;
  description: string;
  variants: string[];
  startDate: string;
  endDate?: string;
  status: 'active' | 'completed' | 'scheduled';
  createdAt: string;
}

interface TestResult {
  testId: string;
  variant: string;
  userId: string;
  success: boolean;
  metrics: any;
  timestamp: string;
}

export class ABTestingService {
  /**
   * Skapa ett nytt A/B-test
   */
  async createTest(
    name: string, 
    description: string, 
    variants: string[], 
    startDate: string
  ): Promise<string> {
    try {
      const id = crypto.randomUUID();
      const test: Test = {
        id,
        name,
        description,
        variants,
        startDate,
        status: new Date(startDate) <= new Date() ? 'active' : 'scheduled',
        createdAt: new Date().toISOString()
      };
      
      await supabase
        .from('ab_tests')
        .insert(test);
      
      logger.info('New A/B test created', { id, name });
      return id;
    } catch (error: any) {
      logger.error('Failed to create A/B test', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Hämta aktiva tester
   */
  async getActiveTests(): Promise<Test[]> {
    try {
      const { data, error } = await supabase
        .from('ab_tests')
        .select('*')
        .eq('status', 'active');
      
      if (error) {
        throw error;
      }
      
      return data || [];
    } catch (error: any) {
      logger.error('Failed to get active tests', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Tilldela en variant till en användare för ett specifikt test
   */
  async assignVariant(testId: string, userId: string): Promise<string> {
    try {
      // Kontrollera om användaren redan har en variant
      const { data: existingAssignment, error: assignmentError } = await supabase
        .from('ab_test_assignments')
        .select('*')
        .eq('test_id', testId)
        .eq('user_id', userId)
        .maybeSingle();
      
      if (assignmentError) {
        throw assignmentError;
      }
      
      // Om användaren redan har en variant, återanvänd den
      if (existingAssignment) {
        return existingAssignment.variant;
      }
      
      // Hämta testet för att få varianterna
      const { data: test, error: testError } = await supabase
        .from('ab_tests')
        .select('*')
        .eq('id', testId)
        .single();
      
      if (testError) {
        throw testError;
      }
      
      // Slumpmässigt välja en variant
      const variant = test.variants[Math.floor(Math.random() * test.variants.length)];
      
      // Spara tilldelningen
      await supabase
        .from('ab_test_assignments')
        .insert({
          test_id: testId,
          user_id: userId,
          variant,
          assigned_at: new Date().toISOString()
        });
      
      logger.info('Variant assigned to user', { testId, userId, variant });
      return variant;
    } catch (error: any) {
      logger.error('Failed to assign variant', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Registrera ett testresultat
   */
  async trackResult(
    testId: string, 
    variant: string, 
    userId: string, 
    success: boolean, 
    metrics: any
  ): Promise<void> {
    try {
      const result: TestResult = {
        testId,
        variant,
        userId,
        success,
        metrics,
        timestamp: new Date().toISOString()
      };
      
      await supabase
        .from('ab_test_results')
        .insert(result);
      
      logger.info('A/B test result tracked', { testId, variant, success });
    } catch (error: any) {
      logger.error('Failed to track test result', { error: error.message });
    }
  }
  
  /**
   * Hämta testresultat
   */
  async getTestResults(testId: string): Promise<any> {
    try {
      const { data: test, error: testError } = await supabase
        .from('ab_tests')
        .select('*')
        .eq('id', testId)
        .single();
      
      if (testError) {
        throw testError;
      }
      
      const { data: results, error: resultsError } = await supabase
        .from('ab_test_results')
        .select('*')
        .eq('testId', testId);
      
      if (resultsError) {
        throw resultsError;
      }
      
      // Gruppera resultat per variant
      const resultsByVariant: { [key: string]: any[] } = {};
      test.variants.forEach(variant => {
        resultsByVariant[variant] = [];
      });
      
      results.forEach(result => {
        if (resultsByVariant[result.variant]) {
          resultsByVariant[result.variant].push(result);
        }
      });
      
      // Beräkna statistik för varje variant
      const statsByVariant: { [key: string]: any } = {};
      Object.entries(resultsByVariant).forEach(([variant, variantResults]) => {
        const totalCount = variantResults.length;
        const successCount = variantResults.filter(r => r.success).length;
        const successRate = totalCount > 0 ? (successCount / totalCount) * 100 : 0;
        
        // Beräkna genomsnittliga mätvärden
        const avgMetrics: { [key: string]: number } = {};
        if (totalCount > 0 && variantResults[0]?.metrics) {
          Object.keys(variantResults[0].metrics).forEach(metricKey => {
            if (typeof variantResults[0].metrics[metricKey] === 'number') {
              avgMetrics[metricKey] = variantResults.reduce((sum, r) => sum + (r.metrics[metricKey] || 0), 0) / totalCount;
            }
          });
        }
        
        statsByVariant[variant] = {
          totalCount,
          successCount,
          successRate,
          avgMetrics
        };
      });
      
      return {
        test,
        statsByVariant
      };
    } catch (error: any) {
      logger.error('Failed to get test results', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Avsluta ett test
   */
  async completeTest(testId: string): Promise<void> {
    try {
      await supabase
        .from('ab_tests')
        .update({
          status: 'completed',
          endDate: new Date().toISOString()
        })
        .eq('id', testId);
      
      logger.info('A/B test completed', { testId });
    } catch (error: any) {
      logger.error('Failed to complete test', { error: error.message });
      throw error;
    }
  }
}

export default new ABTestingService();
```

### 5. Implementera en användarfeedbackmekanism

Skapa en struktur för att samla in och hantera användarfeedback:

```typescript
// src/services/feedbackService.ts
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';

export enum FeedbackType {
  INCORRECT_ANALYSIS = 'incorrect_analysis',
  MISSING_INGREDIENT = 'missing_ingredient',
  FALSE_POSITIVE = 'false_positive',
  FALSE_NEGATIVE = 'false_negative',
  FEATURE_REQUEST = 'feature_request',
  GENERAL = 'general'
}

interface Feedback {
  id: string;
  userId: string;
  analysisId?: string;
  type: FeedbackType;
  description: string;
  productDetails?: any;
  screenshot?: string;
  timestamp: string;
  status: 'open' | 'in_progress' | 'resolved' | 'closed';
}

export class FeedbackService {
  /**
   * Registrera ny feedback
   */
  async submitFeedback(
    userId: string, 
    type: FeedbackType, 
    description: string, 
    analysisId?: string, 
    productDetails?: any,
    screenshot?: string
  ): Promise<string> {
    try {
      const id = crypto.randomUUID();
      const feedback: Feedback = {
        id,
        userId,
        analysisId,
        type,
        description,
        productDetails,
        screenshot,
        timestamp: new Date().toISOString(),
        status: 'open'
      };
      
      await supabase
        .from('user_feedback')
        .insert(feedback);
      
      // Notifiera om ny feedback
      this.notifyNewFeedback(feedback);
      
      logger.info('New feedback submitted', { id, type, userId });
      return id;
    } catch (error: any) {
      logger.error('Failed to submit feedback', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Hämta all feedback
   */
  async getAllFeedback(
    status?: 'open' | 'in_progress' | 'resolved' | 'closed',
    type?: FeedbackType
  ): Promise<Feedback[]> {
    try {
      let query = supabase
        .from('user_feedback')
        .select('*');
      
      if (status) {
        query = query.eq('status', status);
      }
      
      if (type) {
        query = query.eq('type', type);
      }
      
      const { data, error } = await query;
      
      if (error) {
        throw error;
      }
      
      return data || [];
    } catch (error: any) {
      logger.error('Failed to get feedback', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Uppdatera feedbackstatus
   */
  async updateFeedbackStatus(
    id: string, 
    status: 'open' | 'in_progress' | 'resolved' | 'closed',
    comment?: string
  ): Promise<void> {
    try {
      await supabase
        .from('user_feedback')
        .update({
          status,
          updated_at: new Date().toISOString(),
          admin_comment: comment
        })
        .eq('id', id);
      
      logger.info('Feedback status updated', { id, status });
    } catch (error: any) {
      logger.error('Failed to update feedback status', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Notifiera om ny feedback (t.ex. via Slack)
   */
  private async notifyNewFeedback(feedback: Feedback): Promise<void> {
    // Implementera notifiering via webhook eller e-post
    try {
      // Exempel: Skicka till Slack webhook
      if (process.env.SLACK_WEBHOOK_URL) {
        const response = await fetch(process.env.SLACK_WEBHOOK_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: `Ny feedback i KoaLens:\nTyp: ${feedback.type}\nBeskrivning: ${feedback.description}\nAnvändare: ${feedback.userId}`
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to send Slack notification: ${response.statusText}`);
        }
      }
    } catch (error: any) {
      logger.error('Failed to notify about new feedback', { error: error.message });
    }
  }
}

export default new FeedbackService();
```

### 6. Implementera automatiserad modellövervakning

Skapa ett system för att automatiskt övervaka modellprestanda och larma vid problem:

```typescript
// src/services/modelMonitoringService.ts
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';

interface AlertThreshold {
  metric: string;
  operator: '>' | '<' | '>=' | '<=' | '==';
  threshold: number;
  severity: 'info' | 'warning' | 'critical';
}

interface Alert {
  id: string;
  metric: string;
  value: number;
  threshold: number;
  severity: 'info' | 'warning' | 'critical';
  timestamp: string;
  resolved: boolean;
  resolvedAt?: string;
}

export class ModelMonitoringService {
  private alertThresholds: AlertThreshold[] = [
    { metric: 'error_rate', operator: '>', threshold: 0.1, severity: 'warning' },
    { metric: 'error_rate', operator: '>', threshold: 0.2, severity: 'critical' },
    { metric: 'uncertainty_rate', operator: '>', threshold: 0.15, severity: 'warning' },
    { metric: 'uncertainty_rate', operator: '>', threshold: 0.3, severity: 'critical' },
    { metric: 'avg_response_time', operator: '>', threshold: 2000, severity: 'warning' },
    { metric: 'avg_response_time', operator: '>', threshold: 5000, severity: 'critical' }
  ];
  
  /**
   * Kör en övervakningscheck
   */
  async runMonitoringCheck(): Promise<void> {
    try {
      // Hämta data för de senaste 24 timmarna
      const endDate = new Date();
      const startDate = new Date();
      startDate.setHours(startDate.getHours() - 24);
      
      const { data, error } = await supabase
        .from('analysis_metrics')
        .select('*')
        .gte('timestamp', startDate.toISOString())
        .lte('timestamp', endDate.toISOString());
      
      if (error) {
        throw error;
      }
      
      if (!data || data.length === 0) {
        logger.info('No data found for monitoring check');
        return;
      }
      
      // Beräkna metriker
      const totalCount = data.length;
      const errorCount = data.filter(item => item.error === true).length;
      const uncertainCount = data.filter(item => item.isVegan === null).length;
      const totalResponseTime = data.reduce((sum, item) => sum + item.responseTimeMs, 0);
      
      const metrics = {
        error_rate: errorCount / totalCount,
        uncertainty_rate: uncertainCount / totalCount,
        avg_response_time: totalResponseTime / totalCount
      };
      
      // Kontrollera varje tröskel
      for (const threshold of this.alertThresholds) {
        const metricValue = metrics[threshold.metric];
        
        if (!metricValue) {
          continue;
        }
        
        let isAlertTriggered = false;
        
        switch (threshold.operator) {
          case '>':
            isAlertTriggered = metricValue > threshold.threshold;
            break;
          case '<':
            isAlertTriggered = metricValue < threshold.threshold;
            break;
          case '>=':
            isAlertTriggered = metricValue >= threshold.threshold;
            break;
          case '<=':
            isAlertTriggered = metricValue <= threshold.threshold;
            break;
          case '==':
            isAlertTriggered = metricValue === threshold.threshold;
            break;
        }
        
        if (isAlertTriggered) {
          await this.createAlert(threshold.metric, metricValue, threshold.threshold, threshold.severity);
        }
      }
      
      logger.info('Monitoring check completed', { metrics });
    } catch (error: any) {
      logger.error('Failed to run monitoring check', { error: error.message });
    }
  }
  
  /**
   * Skapa en varning
   */
  private async createAlert(
    metric: string, 
    value: number, 
    threshold: number, 
    severity: 'info' | 'warning' | 'critical'
  ): Promise<void> {
    try {
      const alert: Alert = {
        id: crypto.randomUUID(),
        metric,
        value,
        threshold,
        severity,
        timestamp: new Date().toISOString(),
        resolved: false
      };
      
      await supabase
        .from('model_alerts')
        .insert(alert);
      
      // Notifiera om varningen
      await this.notifyAlert(alert);
      
      logger.info('Model alert created', { alert });
    } catch (error: any) {
      logger.error('Failed to create alert', { error: error.message });
    }
  }
  
  /**
   * Notifiera om en varning
   */
  private async notifyAlert(alert: Alert): Promise<void> {
    try {
      // Notifiera via e-post
      if (process.env.ALERT_EMAIL) {
        // Implementera e-postnotifiering här
      }
      
      // Notifiera via Slack
      if (process.env.SLACK_WEBHOOK_URL) {
        const color = alert.severity === 'critical' ? '#ff0000' : 
                     alert.severity === 'warning' ? '#ffcc00' : '#0099cc';
        
        const response = await fetch(process.env.SLACK_WEBHOOK_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            attachments: [
              {
                color,
                title: `KoaLens ${alert.severity.toUpperCase()} Alert: ${alert.metric}`,
                text: `Metric: ${alert.metric}\nValue: ${alert.value}\nThreshold: ${alert.threshold}\nSeverity: ${alert.severity}\nTimestamp: ${alert.timestamp}`,
                fallback: `KoaLens Alert: ${alert.metric} = ${alert.value}`
              }
            ]
          })
        });
        
        if (!response.ok) {
          throw new Error(`Failed to send Slack notification: ${response.statusText}`);
        }
      }
    } catch (error: any) {
      logger.error('Failed to notify about alert', { error: error.message });
    }
  }
  
  /**
   * Markera en varning som löst
   */
  async resolveAlert(id: string): Promise<void> {
    try {
      await supabase
        .from('model_alerts')
        .update({
          resolved: true,
          resolvedAt: new Date().toISOString()
        })
        .eq('id', id);
      
      logger.info('Alert resolved', { id });
    } catch (error: any) {
      logger.error('Failed to resolve alert', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Konfigurera schemalagd övervakning
   */
  scheduleMonitoring(intervalMinutes: number = 60): void {
    setInterval(() => {
      this.runMonitoringCheck().catch(err => {
        logger.error('Scheduled monitoring check failed', { error: err.message });
      });
    }, intervalMinutes * 60 * 1000);
    
    logger.info(`Scheduled monitoring check every ${intervalMinutes} minutes`);
  }
}

export default new ModelMonitoringService();
```

### 7. Planera för långsiktig modelluppgradering

Skapa ett förberett anpassningslager för framtida modelluppdateringar:

```typescript
// src/services/aiModelVersionController.ts
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';
import { AIServiceFactory } from './aiServiceFactory';

interface ModelVersion {
  id: string;
  provider: string;
  version: string;
  description: string;
  releaseDate: string;
  status: 'available' | 'deprecated' | 'planned';
  apiEndpoint?: string;
  requiredParams?: string[];
}

export class AIModelVersionController {
  /**
   * Registrera en ny modellversion
   */
  async registerModelVersion(
    provider: string,
    version: string,
    description: string,
    releaseDate: string,
    status: 'available' | 'deprecated' | 'planned' = 'available',
    apiEndpoint?: string,
    requiredParams?: string[]
  ): Promise<string> {
    try {
      const id = crypto.randomUUID();
      const modelVersion: ModelVersion = {
        id,
        provider,
        version,
        description,
        releaseDate,
        status,
        apiEndpoint,
        requiredParams
      };
      
      await supabase
        .from('model_versions')
        .insert(modelVersion);
      
      logger.info('New model version registered', { id, provider, version });
      return id;
    } catch (error: any) {
      logger.error('Failed to register model version', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Hämta alla tillgängliga modellversioner
   */
  async getAvailableModels(): Promise<ModelVersion[]> {
    try {
      const { data, error } = await supabase
        .from('model_versions')
        .select('*')
        .eq('status', 'available');
      
      if (error) {
        throw error;
      }
      
      return data || [];
    } catch (error: any) {
      logger.error('Failed to get available models', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Sätt aktuell aktiv modellversion
   */
  async setActiveModelVersion(versionId: string): Promise<void> {
    try {
      // Hämta modellversionen
      const { data: modelVersion, error } = await supabase
        .from('model_versions')
        .select('*')
        .eq('id', versionId)
        .single();
      
      if (error) {
        throw error;
      }
      
      // Uppdatera miljövariablerna
      if (modelVersion.provider === 'gemini') {
        process.env.GEMINI_MODEL_NAME = modelVersion.version;
        process.env.AI_PROVIDER = 'gemini';
        
        if (modelVersion.apiEndpoint) {
          process.env.GEMINI_API_ENDPOINT = modelVersion.apiEndpoint;
        }
      } else if (modelVersion.provider === 'claude') {
        process.env.CLAUDE_MODEL_NAME = modelVersion.version;
        process.env.AI_PROVIDER = 'claude';
        
        if (modelVersion.apiEndpoint) {
          process.env.CLAUDE_API_ENDPOINT = modelVersion.apiEndpoint;
        }
      }
      
      // Uppdatera konfigurationen
      await supabase
        .from('system_config')
        .update({
          value: versionId
        })
        .eq('key', 'active_model_version');
      
      // Återställ AIServiceFactory-instanser för att använda nya konfigurationen
      AIServiceFactory.resetInstances();
      
      logger.info('Active model version set', { versionId, provider: modelVersion.provider, version: modelVersion.version });
    } catch (error: any) {
      logger.error('Failed to set active model version', { error: error.message });
      throw error;
    }
  }
  
  /**
   * Utvärdera en ny modellversion mot den aktiva
   */
  async evaluateModelVersion(
    versionId: string,
    testCases: { ingredients: string[] }[] = [],
    sampleSize: number = 100
  ): Promise<any> {
    try {
      // Hämta den nya modellversionen
      const { data: newModelVersion, error: newModelError } = await supabase
        .from('model_versions')
        .select('*')
        .eq('id', versionId)
        .single();
      
      if (newModelError) {
        throw newModelError;
      }
      
      // Hämta den aktiva modellversionen
      const { data: systemConfig, error: configError } = await supabase
        .from('system_config')
        .select('*')
        .eq('key', 'active_model_version')
        .single();
      
      if (configError) {
        throw configError;
      }
      
      const { data: activeModelVersion, error: activeModelError } = await supabase
        .from('model_versions')
        .select('*')
        .eq('id', systemConfig.value)
        .single();
      
      if (activeModelError) {
        throw activeModelError;
      }
      
      // Förbered testfall
      let testSuites = testCases;
      
      // Om inga testfall tillhandahålls, hämta tidigare analyser
      if (testSuites.length === 0) {
        const { data: sampleAnalyses, error: samplesError } = await supabase
          .from('analysis_metrics')
          .select('*')
          .order('timestamp', { ascending: false })
          .limit(sampleSize);
        
        if (samplesError) {
          throw samplesError;
        }
        
        testSuites = sampleAnalyses.map(analysis => ({
          ingredients: analysis.ingredientList || []
        }));
      }
      
      // Utför test med båda modellerna
      const results = {
        activeModel: {
          version: activeModelVersion.version,
          provider: activeModelVersion.provider,
          results: []
        },
        newModel: {
          version: newModelVersion.version,
          provider: newModelVersion.provider,
          results: []
        },
        comparison: {
          totalTests: testSuites.length,
          agreement: 0,
          disagreement: 0,
          newModelFaster: 0,
          activeModelFaster: 0,
          averageSpeedDiffMs: 0
        }
      };
      
      // Konfigurerbara tjänster för varje modell
      const activeModelService = await AIServiceFactory.getService(activeModelVersion.provider);
      const tempEnv = { ...process.env };
      
      // Ställ in miljövariabler för nya modellen
      if (newModelVersion.provider === 'gemini') {
        process.env.GEMINI_MODEL_NAME = newModelVersion.version;
        if (newModelVersion.apiEndpoint) {
          process.env.GEMINI_API_ENDPOINT = newModelVersion.apiEndpoint;
        }
      } else if (newModelVersion.provider === 'claude') {
        process.env.CLAUDE_MODEL_NAME = newModelVersion.version;
        if (newModelVersion.apiEndpoint) {
          process.env.CLAUDE_API_ENDPOINT = newModelVersion.apiEndpoint;
        }
      }
      
      // Återställ AIServiceFactory för nya modellen
      AIServiceFactory.resetInstances();
      const newModelService = await AIServiceFactory.getService(newModelVersion.provider);
      
      // Utför tester
      for (const testCase of testSuites) {
        const prompt = promptManager.format('ingredientsAnalysis', {
          ingredients: testCase.ingredients.join(', ')
        });
        
        // Test med aktiv modell
        const activeStartTime = Date.now();
        const activeResponse = await activeModelService.generateContent(prompt);
        const activeEndTime = Date.now();
        const activeResult = outputParser.parseAnalysisResult(activeResponse);
        
        // Test med ny modell
        const newStartTime = Date.now();
        const newResponse = await newModelService.generateContent(prompt);
        const newEndTime = Date.now();
        const newResult = outputParser.parseAnalysisResult(newResponse);
        
        // Jämför resultat
        const activeResponseTime = activeEndTime - activeStartTime;
        const newResponseTime = newEndTime - newStartTime;
        const isVeganAgreement = activeResult.isVegan === newResult.isVegan;
        
        results.activeModel.results.push({
          isVegan: activeResult.isVegan,
          confidence: activeResult.confidence,
          responseTimeMs: activeResponseTime
        });
        
        results.newModel.results.push({
          isVegan: newResult.isVegan,
          confidence: newResult.confidence,
          responseTimeMs: newResponseTime
        });
        
        if (isVeganAgreement) {
          results.comparison.agreement++;
        } else {
          results.comparison.disagreement++;
        }
        
        if (newResponseTime < activeResponseTime) {
          results.comparison.newModelFaster++;
        } else {
          results.comparison.activeModelFaster++;
        }
      }
      
      // Återställ miljövariabler
      process.env = tempEnv;
      AIServiceFactory.resetInstances();
      
      // Beräkna jämförelsemetrik
      results.comparison.averageSpeedDiffMs = 
        results.newModel.results.reduce((sum, r, i) => sum + (results.activeModel.results[i].responseTimeMs - r.responseTimeMs), 0) / 
        testSuites.length;
      
      // Spara utvärderingsresultat
      await supabase
        .from('model_evaluations')
        .insert({
          id: crypto.randomUUID(),
          new_model_id: versionId,
          active_model_id: systemConfig.value,
          results,
          test_cases_count: testSuites.length,
          timestamp: new Date().toISOString()
        });
      
      return results;
    } catch (error: any) {
      logger.error('Failed to evaluate model version', { error: error.message });
      throw error;
    }
  }
}

export default new AIModelVersionController();
```

### 8. Skapa en process för regelbundna granskningar

Skapa ett script för att generera och skicka ut regelbundna prestandarapporter:

```bash
#!/bin/bash
# scripts/generate_performance_report.sh

NODE_ENV=production node scripts/performance_report_generator.js

# Generera PDF-rapport (med puppeteer eller liknande)
NODE_ENV=production node scripts/generate_pdf_report.js

# Skicka rapporten via e-post
if [ -f ./reports/latest_performance_report.pdf ]; then
  echo "Skickar rapport..."
  node scripts/send_report_email.js
else
  echo "Ingen rapport genererad"
fi
```

Implementera schemaläggningen i package.json:

```json
"scripts": {
  "start": "node dist/server.js",
  "dev": "ts-node-dev src/server.ts",
  "build": "tsc",
  "test": "jest",
  "performance-report": "bash scripts/generate_performance_report.sh",
  "weekly-report": "REPORT_TYPE=weekly bash scripts/generate_performance_report.sh",
  "monthly-report": "REPORT_TYPE=monthly bash scripts/generate_performance_report.sh"
}
```

### 9. Konfigurera ett diskussionsforum för kunskapsutbyte

Skapa ett enkelt forum för teamet att diskutera förbättringar och dela kunskap:

```typescript
// src/routes/forumRoutes.ts
import { Router } from 'express';
import logger from '../utils/logger';
import { supabase } from '../lib/supabase';

const router = Router();

// Autentiseringsskydd för teamforum
const authMiddleware = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  if (apiKey !== process.env.TEAM_API_KEY) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
};

router.use(authMiddleware);

// Hämta alla diskussioner
router.get('/discussions', async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('forum_discussions')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) {
      throw error;
    }
    
    return res.json(data);
  } catch (error: any) {
    logger.error('Failed to get discussions', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

// Skapa en ny diskussion
router.post('/discussions', async (req, res) => {
  try {
    const { title, content, authorId, authorName, tags } = req.body;
    
    const { data, error } = await supabase
      .from('forum_discussions')
      .insert({
        id: crypto.randomUUID(),
        title,
        content,
        author_id: authorId,
        author_name: authorName,
        tags,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select();
    
    if (error) {
      throw error;
    }
    
    return res.json(data[0]);
  } catch (error: any) {
    logger.error('Failed to create discussion', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

// Svara på en diskussion
router.post('/discussions/:id/replies', async (req, res) => {
  try {
    const { id } = req.params;
    const { content, authorId, authorName } = req.body;
    
    const { data, error } = await supabase
      .from('forum_replies')
      .insert({
        id: crypto.randomUUID(),
        discussion_id: id,
        content,
        author_id: authorId,
        author_name: authorName,
        created_at: new Date().toISOString()
      })
      .select();
    
    if (error) {
      throw error;
    }
    
    return res.json(data[0]);
  } catch (error: any) {
    logger.error('Failed to create reply', { error: error.message });
    return res.status(500).json({ error: error.message });
  }
});

export default router;
```

## Verifiering

För att verifiera att du har implementerat en hållbar strategi för iterativ förbättring:

1. Kontrollera att alla nödvändiga tjänster och datamodeller är korrekt konfigurerade:
```bash
# Verifiera databastabeller
psql -U username -h hostname -d database -c "\dt"

# Kontrollera att API:erna fungerar
curl -X GET http://localhost:3000/admin/performance \
  -H "x-api-key: your-admin-api-key"
```

2. Testa datainsamlingssystemet:
```javascript
// Manuellt test av analysmetriker
analyticsService.trackAnalysis({
  provider: 'gemini',
  contentType: 'text',
  responseTimeMs: 1200,
  isVegan: true,
  confidence: 0.9,
  ingredientCount: 5,
  nonVeganCount: 0,
  promptTemplate: 'ingredientsAnalysis_sv'
});
```

3. Verifiera att övervakningssystemet fungerar:
```bash
# Kör en manuell övervakningscheck
curl -X POST http://localhost:3000/admin/run-monitoring-check \
  -H "x-api-key: your-admin-api-key"
```

4. Skapa ett första A/B-test för att validera testramverket:
```javascript
// Skapa ett A/B-test för promptvarianter
abTestingService.createTest(
  'Prompt optimization test',
  'Testing two different promptformats for ingredient analysis',
  ['ingredientsAnalysis_v1', 'ingredientsAnalysis_v2'],
  new Date().toISOString()
);
```

## Felsökning

### Problem: Data samlas inte in korrekt
**Lösning**: Kontrollera databasens konfiguration och anslutning:
```bash
# Kontrollera databasanslutning
psql -U username -h hostname -d database -c "SELECT COUNT(*) FROM analysis_metrics"

# Verifiera att datainsamlingen fungerar
curl -X POST http://localhost:3000/admin/test-analytics \
  -H "Content-Type: application/json" \
  -H "x-api-key: your-admin-api-key" \
  -d '{"test":"data"}'
```

### Problem: Feedback-system fungerar inte
**Lösning**: Kontrollera API-routerna och frontend-integrationen:
```bash
# Testa feedback-API
curl -X POST http://localhost:3000/api/feedback \
  -H "Content-Type: application/json" \
  -d '{"userId":"test-user","type":"general","description":"Test feedback"}'
```

### Problem: A/B-testning ger inkonsekventa resultat
**Lösning**: Kontrollera att användarvarianttilldelningen fungerar korrekt:
```javascript
// Logga varianttilldelningen för att säkerställa konsistens
console.log(await abTestingService.getAssignments('test-id'));
```

## Nästa steg

Nu har du implementerat en robust strategi för kontinuerlig förbättring av Gemini-implementationen. Beroende på resultaten från de första veckorna av drift, bör du överväga följande nästa steg:

1. **Ytterligare automatisering**: Implementera fler automatiska optimeringsåtgärder baserat på insamlad data.
2. **Avancerad A/B-testning**: Utöka A/B-testramverket för att stödja mer komplexa experiment med flera variabler.
3. **Användarfeedbacksloop**: Förbättra kopplingsmekanismen mellan användarfeedback och systemförbättringar.
4. **Utbildning och dokumentation**: Håll teamet uppdaterat om bästa praxis för att arbeta med Gemini 2.5 Pro.
5. **Förberedelser för nästa modellversion**: Håll koll på kommande uppdateringar av Gemini eller andra konkurrerande modeller.

## Referenser
- [Google Gemini Release Notifications](https://ai.google.dev/blog)
- [Continuous Model Monitoring Best Practices](https://cloud.google.com/ai-platform/prediction/docs/continuous-evaluation)
- [A/B Testing for Machine Learning Models](https://towardsdatascience.com/a-b-testing-for-machine-learning-models-23d082a83f35)
- [Prompt Engineering Optimization Techniques](https://www.promptingguide.ai/)
- [Supabase Database Schema Management](https://supabase.com/docs/guides/database)
- [Winston Logging Best Practices](https://github.com/winstonjs/winston/blob/master/examples/quick-start.js)

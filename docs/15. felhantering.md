# Steg 15: Felhantering

## Mål och syfte
Implementera en robust felhanteringsstrategi för hela applikationen som täcker alla potentiella felscenarier när Gemini 2.5 Pro används. Detta steg fokuserar på att förbättra användarupplevelsen genom att hantera och återhämta sig från olika typer av fel, ge användarna meningsfull feedback, och säkerställa att applikationen är stabil även när problem uppstår.

## Förutsättningar
- Implementerade backend- och frontend-komponenter
- Grundläggande kunskap om felhantering i Node.js och React Native
- Komplett system för integration med Gemini API
- Slutförda integrationstest

## Detaljerade instruktioner

### 1. Implementera en centraliserad felhanteringsstrategi i backend

Skapa en struktur för konsekvent felhantering genom hela backend-applikationen:

```typescript
// src/utils/errorHandler.ts
import logger from './logger';

// Definiera feltyper
export enum ErrorType {
  // API-relaterade fel
  API_CONNECTION_ERROR = 'API_CONNECTION_ERROR',
  API_QUOTA_EXCEEDED = 'API_QUOTA_EXCEEDED',
  API_AUTHENTICATION_ERROR = 'API_AUTHENTICATION_ERROR',
  API_RESPONSE_ERROR = 'API_RESPONSE_ERROR',
  
  // Innehållsrelaterade fel
  CONTENT_PARSING_ERROR = 'CONTENT_PARSING_ERROR',
  CONTENT_VALIDATION_ERROR = 'CONTENT_VALIDATION_ERROR',
  CONTENT_FORMAT_ERROR = 'CONTENT_FORMAT_ERROR',
  INGREDIENTS_DETECTION_ERROR = 'INGREDIENTS_DETECTION_ERROR',
  
  // Mediahanteringsfel
  MEDIA_PROCESSING_ERROR = 'MEDIA_PROCESSING_ERROR',
  MEDIA_COMPRESSION_ERROR = 'MEDIA_COMPRESSION_ERROR',
  MEDIA_FORMAT_ERROR = 'MEDIA_FORMAT_ERROR',
  VIDEO_PROCESSING_ERROR = 'VIDEO_PROCESSING_ERROR',
  
  // Nätverksfel
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  
  // Databasfel
  DATABASE_CONNECTION_ERROR = 'DATABASE_CONNECTION_ERROR',
  DATABASE_QUERY_ERROR = 'DATABASE_QUERY_ERROR',
  
  // Serverfel
  SERVER_ERROR = 'SERVER_ERROR',
  
  // Okänt fel
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

// Standardstruktur för API-fel
export interface ApiError {
  type: ErrorType;
  message: string;
  code?: number;
  details?: any;
  displayMessage: string; // Användarvänligt meddelande
  recoverable: boolean; // Kan åtgärdas av användaren
  recommendedAction?: string; // Rekommenderad åtgärd
}

/**
 * Skapa ett standardiserat API-fel
 */
export function createApiError(
  type: ErrorType,
  message: string,
  options?: {
    code?: number;
    details?: any;
    displayMessage?: string;
    recoverable?: boolean;
    recommendedAction?: string;
  }
): ApiError {
  // Generera användarvänliga meddelanden baserat på feltyp
  let defaultDisplayMessage = 'Ett fel har uppstått.';
  let defaultRecoverable = false;
  let defaultRecommendedAction = 'Försök igen senare.';
  
  switch (type) {
    case ErrorType.API_CONNECTION_ERROR:
      defaultDisplayMessage = 'Kunde inte ansluta till analysmotorn.';
      defaultRecoverable = true;
      defaultRecommendedAction = 'Kontrollera din internetanslutning och försök igen.';
      break;
      
    case ErrorType.API_QUOTA_EXCEEDED:
      defaultDisplayMessage = 'Du har nått din analysgräns för perioden.';
      defaultRecoverable = false;
      defaultRecommendedAction = 'Vänta till nästa månad eller uppgradera din plan.';
      break;
      
    case ErrorType.CONTENT_PARSING_ERROR:
      defaultDisplayMessage = 'Kunde inte tolka ingredienserna.';
      defaultRecoverable = true;
      defaultRecommendedAction = 'Försök med en tydligare bild av ingredienslistan.';
      break;
      
    case ErrorType.MEDIA_PROCESSING_ERROR:
      defaultDisplayMessage = 'Kunde inte bearbeta bilden eller videon.';
      defaultRecoverable = true;
      defaultRecommendedAction = 'Försök med en annan bild eller inspelning.';
      break;
      
    case ErrorType.VIDEO_PROCESSING_ERROR:
      defaultDisplayMessage = 'Kunde inte bearbeta videoinspelningen.';
      defaultRecoverable = true;
      defaultRecommendedAction = 'Försök med en kortare video med bättre ljus.';
      break;
      
    case ErrorType.NETWORK_ERROR:
      defaultDisplayMessage = 'Nätverksfel. Kunde inte kommunicera med servern.';
      defaultRecoverable = true;
      defaultRecommendedAction = 'Kontrollera din internetanslutning och försök igen.';
      break;
      
    case ErrorType.TIMEOUT_ERROR:
      defaultDisplayMessage = 'Tidsfristen överskreds. Begäran tog för lång tid.';
      defaultRecoverable = true;
      defaultRecommendedAction = 'Försök igen med en mindre bild eller kortare video.';
      break;
      
    // Lägg till fler feltyper efter behov
  }
  
  // Skapa och returnera felobjektet
  const error: ApiError = {
    type,
    message,
    code: options?.code,
    details: options?.details,
    displayMessage: options?.displayMessage || defaultDisplayMessage,
    recoverable: options?.recoverable !== undefined ? options?.recoverable : defaultRecoverable,
    recommendedAction: options?.recommendedAction || defaultRecommendedAction
  };
  
  // Logga felet
  logger.error('API Error', {
    type: error.type,
    message: error.message,
    code: error.code,
    details: error.details
  });
  
  return error;
}

/**
 * Konvertera Error-objekt till standardiserade API-fel
 */
export function convertErrorToApiError(error: any): ApiError {
  if (error.name === 'ApiError') {
    return error as ApiError;
  }
  
  // Identifiera feltyp baserat på felmeddelande eller egenskaper
  let type = ErrorType.UNKNOWN_ERROR;
  let code: number | undefined = undefined;
  
  if (error.response) {
    // Axios-fel eller liknande med response-objekt
    code = error.response.status;
    
    if (code === 401 || code === 403) {
      type = ErrorType.API_AUTHENTICATION_ERROR;
    } else if (code === 429) {
      type = ErrorType.API_QUOTA_EXCEEDED;
    } else if (code >= 500) {
      type = ErrorType.API_RESPONSE_ERROR;
    }
  } else if (error.request) {
    // En förfrågan gjordes men inget svar mottogs
    type = ErrorType.API_CONNECTION_ERROR;
  } else if (error.message && typeof error.message === 'string') {
    // Felmeddelande-baserad identifiering
    const message = error.message.toLowerCase();
    
    if (message.includes('network') || message.includes('connection')) {
      type = ErrorType.NETWORK_ERROR;
    } else if (message.includes('timeout')) {
      type = ErrorType.TIMEOUT_ERROR;
    } else if (message.includes('quota') || message.includes('rate limit')) {
      type = ErrorType.API_QUOTA_EXCEEDED;
    } else if (message.includes('authentication') || message.includes('unauthorized')) {
      type = ErrorType.API_AUTHENTICATION_ERROR;
    } else if (message.includes('parse') || message.includes('json')) {
      type = ErrorType.CONTENT_PARSING_ERROR;
    } else if (message.includes('process') && (message.includes('image') || message.includes('video'))) {
      type = ErrorType.MEDIA_PROCESSING_ERROR;
    }
  }
  
  return createApiError(
    type,
    error.message || 'Ett oväntat fel har uppstått',
    {
      code,
      details: {
        stack: error.stack,
        originalError: error
      }
    }
  );
}

/**
 * Global felhanteringsfunktion för middleware
 */
export function errorMiddleware(err: any, req: any, res: any, next: any) {
  const apiError = convertErrorToApiError(err);
  
  res.status(apiError.code || 500).json({
    error: apiError.type,
    message: apiError.displayMessage,
    recoverable: apiError.recoverable,
    recommendedAction: apiError.recommendedAction
  });
}
```

### 2. Förbättra felhantering i Gemini Service

Uppdatera GeminiService för att hantera specifika API-relaterade fel:

```typescript
// Uppdatera src/services/geminiService.ts

import { createApiError, ErrorType } from '../utils/errorHandler';

// I din klass:

async generateContent(prompt: string): Promise<any> {
  try {
    // Befintlig kod...
  } catch (error: any) {
    // Förbättrad felhantering för Gemini API
    
    if (error.status === 429 || error.message?.includes('quota')) {
      throw createApiError(
        ErrorType.API_QUOTA_EXCEEDED,
        'Gemini API quota exceeded',
        {
          details: { originalError: error },
          recoverable: false,
          recommendedAction: 'Försök igen senare eller uppgradera din plan.'
        }
      );
    }
    
    if (error.status === 400 || error.message?.includes('invalid')) {
      throw createApiError(
        ErrorType.CONTENT_VALIDATION_ERROR,
        'Invalid content provided to Gemini API',
        {
          details: { originalError: error },
          recoverable: true,
          recommendedAction: 'Försök med en annan bild eller text.'
        }
      );
    }
    
    if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {
      throw createApiError(
        ErrorType.TIMEOUT_ERROR,
        'Request to Gemini API timed out',
        {
          details: { originalError: error },
          recoverable: true,
          recommendedAction: 'Försök med en kortare förfrågan eller mindre bild/video.'
        }
      );
    }
    
    if (error.message?.includes('network') || error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      throw createApiError(
        ErrorType.NETWORK_ERROR,
        'Network error when connecting to Gemini API',
        {
          details: { originalError: error },
          recoverable: true,
          recommendedAction: 'Kontrollera din internetanslutning och försök igen.'
        }
      );
    }
    
    // För okända fel
    throw createApiError(
      ErrorType.API_RESPONSE_ERROR,
      `Gemini API error: ${error.message}`,
      {
        details: { originalError: error },
        recoverable: true,
        recommendedAction: 'Försök igen eller kontakta support om problemet kvarstår.'
      }
    );
  }
}

// Liknande uppdateringar för andra metoder...
```

### 3. Implementera felhantering för mediabearbetning

Förbättra mediabearbetningen (bild/video) för att hantera specifika fel:

```typescript
// Uppdatering för src/utils/mediaProcessor.ts

import { createApiError, ErrorType } from './errorHandler';

export async function compressVideo(videoBase64: string, options: any): Promise<string> {
  try {
    // Befintlig komprimeringslogik...
  } catch (error: any) {
    if (error.message?.includes('format') || error.message?.includes('codec')) {
      throw createApiError(
        ErrorType.MEDIA_FORMAT_ERROR,
        'Videoformatet stöds inte',
        {
          details: { originalError: error },
          recoverable: true,
          displayMessage: 'Videoformatet stöds inte',
          recommendedAction: 'Försök med en video i MP4-format.'
        }
      );
    }
    
    if (error.message?.includes('size') || error.message?.includes('large')) {
      throw createApiError(
        ErrorType.MEDIA_PROCESSING_ERROR,
        'Video size too large',
        {
          details: { originalError: error },
          recoverable: true,
          displayMessage: 'Videon är för stor för att bearbeta',
          recommendedAction: 'Försök med en kortare video (max 10 sekunder).'
        }
      );
    }
    
    throw createApiError(
      ErrorType.VIDEO_PROCESSING_ERROR,
      `Video processing error: ${error.message}`,
      {
        details: { originalError: error },
        recoverable: true,
        recommendedAction: 'Försök med en annan video eller annan inspelningsinställning.'
      }
    );
  }
}

// Liknande uppdateringar för andra mediabearbetningsfunktioner...
```

### 4. Implementera återförsöksmekanismer

Skapa en återförsöksmekanism för att hantera tillfälliga fel:

```typescript
// src/utils/retryUtils.ts
import logger from './logger';
import { createApiError, ErrorType } from './errorHandler';

interface RetryOptions {
  maxRetries: number;
  initialDelay: number;
  maxDelay: number;
  backoffFactor: number;
  retryableErrors: ErrorType[];
}

const defaultRetryOptions: RetryOptions = {
  maxRetries: 3,
  initialDelay: 1000, // 1 sekund
  maxDelay: 10000, // 10 sekunder
  backoffFactor: 2,
  retryableErrors: [
    ErrorType.API_CONNECTION_ERROR,
    ErrorType.NETWORK_ERROR,
    ErrorType.TIMEOUT_ERROR
  ]
};

/**
 * Utför en operation med automatiska återförsök vid fel
 */
export async function withRetry<T>(
  operation: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const retryOptions: RetryOptions = { ...defaultRetryOptions, ...options };
  let lastError: any;
  let delay = retryOptions.initialDelay;
  
  for (let attempt = 1; attempt <= retryOptions.maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error: any) {
      lastError = error;
      
      // Kontrollera om detta är ett återförsöksbart fel
      const isRetryable = 
        error.type && 
        retryOptions.retryableErrors.includes(error.type as ErrorType);
      
      if (!isRetryable) {
        logger.warn('Non-retryable error, aborting retry logic', { error });
        throw error;
      }
      
      if (attempt >= retryOptions.maxRetries) {
        logger.warn('Max retries reached', { 
          maxRetries: retryOptions.maxRetries, 
          error 
        });
        
        // Kasta specialfel för max återförsök
        throw createApiError(
          error.type || ErrorType.UNKNOWN_ERROR,
          `Operation failed after ${retryOptions.maxRetries} attempts: ${error.message}`,
          {
            details: { 
              originalError: error,
              attempts: attempt
            },
            code: error.code,
            recoverable: error.recoverable,
            displayMessage: `Vi kunde inte slutföra åtgärden efter flera försök. ${error.displayMessage}`,
            recommendedAction: error.recommendedAction || 'Försök igen senare.'
          }
        );
      }
      
      // Beräkna fördröjning med exponentiell backoff
      delay = Math.min(
        delay * retryOptions.backoffFactor,
        retryOptions.maxDelay
      );
      
      // Lägg till lite slumpmässighet (jitter) för att undvika belastningspikar
      delay = delay * (0.75 + Math.random() * 0.5);
      
      logger.info(`Retrying operation after error (attempt ${attempt}/${retryOptions.maxRetries})`, {
        error: error.message,
        delay,
        nextAttempt: attempt + 1
      });
      
      // Vänta innan nästa försök
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  // Denna kod bör aldrig nås, men TypeScript kräver en returväg
  throw lastError;
}

// Hjälpfunktion för att identifiera om ett fel är återförsöksbart
export function isRetryableError(error: any): boolean {
  if (!error || !error.type) return false;
  
  const retryableErrors = [
    ErrorType.API_CONNECTION_ERROR,
    ErrorType.NETWORK_ERROR,
    ErrorType.TIMEOUT_ERROR,
    ErrorType.DATABASE_CONNECTION_ERROR
  ];
  
  return retryableErrors.includes(error.type as ErrorType);
}
```

### 5. Implementera förbättrad offline-hantering

Förbättra offline-hantering för att säkerställa att användare kan använda appen även med begränsad anslutning:

```typescript
// src/utils/networkUtils.ts
import NetInfo from '@react-native-community/netinfo';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createApiError, ErrorType } from './errorHandler';

export interface NetworkStatus {
  isConnected: boolean;
  isInternetReachable: boolean | null;
  type: string;
  details: any;
  lastUpdated: number;
}

// Nyckel för att lagra nätverksstatus i AsyncStorage
const NETWORK_STATUS_KEY = 'KOALENS_NETWORK_STATUS';

/**
 * Hämta aktuell nätverksstatus med cache-stöd
 */
export async function getNetworkStatus(useCachedIfUnavailable = true): Promise<NetworkStatus> {
  try {
    // Försök hämta aktuell nätverksstatus
    const netInfo = await NetInfo.fetch();
    
    const status: NetworkStatus = {
      isConnected: netInfo.isConnected || false,
      isInternetReachable: netInfo.isInternetReachable,
      type: netInfo.type,
      details: netInfo.details,
      lastUpdated: Date.now()
    };
    
    // Spara aktuell status i AsyncStorage för offline-åtkomst
    try {
      await AsyncStorage.setItem(NETWORK_STATUS_KEY, JSON.stringify(status));
    } catch (storageError) {
      console.warn('Failed to cache network status', storageError);
    }
    
    return status;
  } catch (error) {
    // Om vi inte kan hämta nätverksstatus och useCachedIfUnavailable är true
    if (useCachedIfUnavailable) {
      try {
        // Hämta senast kända nätverksstatus
        const cachedStatusStr = await AsyncStorage.getItem(NETWORK_STATUS_KEY);
        
        if (cachedStatusStr) {
          return JSON.parse(cachedStatusStr) as NetworkStatus;
        }
      } catch (storageError) {
        console.warn('Failed to get cached network status', storageError);
      }
    }
    
    // Standardnätverksstatus om inget annat är tillgängligt
    return {
      isConnected: false,
      isInternetReachable: false,
      type: 'unknown',
      details: null,
      lastUpdated: Date.now()
    };
  }
}

/**
 * Kontrollerar om nätverket är tillgängligt för API-anrop
 * Kastar ett standardiserat fel om nätverket inte är tillgängligt
 */
export async function validateNetworkConnection(requireInternetReachable = true): Promise<void> {
  const status = await getNetworkStatus();
  
  if (!status.isConnected) {
    throw createApiError(
      ErrorType.NETWORK_ERROR,
      'Ingen nätverksanslutning tillgänglig',
      {
        recoverable: true,
        details: { networkStatus: status },
        displayMessage: 'Du är inte ansluten till internet',
        recommendedAction: 'Kontrollera din internetanslutning och försök igen'
      }
    );
  }
  
  if (requireInternetReachable && status.isInternetReachable === false) {
    throw createApiError(
      ErrorType.NETWORK_ERROR,
      'Internet är inte nåbart',
      {
        recoverable: true,
        details: { networkStatus: status },
        displayMessage: 'Din internetanslutning verkar inte fungera',
        recommendedAction: 'Kontrollera din internetanslutning och försök igen'
      }
    );
  }
}

/**
 * Konfigurerar en nätverksstatuslysnare för att uppdatera status i hela appen
 */
export function setupNetworkListener(onStatusChange?: (status: NetworkStatus) => void): () => void {
  return NetInfo.addEventListener(netInfo => {
    const status: NetworkStatus = {
      isConnected: netInfo.isConnected || false,
      isInternetReachable: netInfo.isInternetReachable,
      type: netInfo.type,
      details: netInfo.details,
      lastUpdated: Date.now()
    };
    
    // Uppdatera cache
    AsyncStorage.setItem(NETWORK_STATUS_KEY, JSON.stringify(status))
      .catch(error => console.warn('Failed to update cached network status', error));
    
    // Anropa callback om tillgänglig
    if (onStatusChange) {
      onStatusChange(status);
    }
  });
}
```

### 6. Implementera användarfeedback-komponenter

Skapa React Native-komponenter för att presentera användarvänliga felmeddelanden:

```tsx
// src/components/ErrorDisplay.tsx
import React from 'react';
import { View, Text, Pressable, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { ApiError, ErrorType } from '../utils/errorHandler';

interface ErrorDisplayProps {
  error: ApiError;
  onRetry?: () => void;
  onDismiss?: () => void;
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  onRetry,
  onDismiss
}) => {
  // Välj ikon baserat på feltyp
  const getIconName = (): string => {
    switch (error.type) {
      case ErrorType.NETWORK_ERROR:
        return 'cloud-offline-outline';
      case ErrorType.API_QUOTA_EXCEEDED:
        return 'hourglass-outline';
      case ErrorType.MEDIA_PROCESSING_ERROR:
        return 'image-outline';
      case ErrorType.VIDEO_PROCESSING_ERROR:
        return 'videocam-outline';
      case ErrorType.TIMEOUT_ERROR:
        return 'timer-outline';
      default:
        return 'alert-circle-outline';
    }
  };
  
  // Välj bakgrundsfärg baserat på feltyp
  const getBackgroundColor = (): string => {
    if (error.recoverable) {
      return '#FEF3C7'; // Gul bakgrund för återställbara fel
    } else {
      return '#FEE2E2'; // Röd bakgrund för allvarliga fel
    }
  };
  
  return (
    <View style={[styles.container, { backgroundColor: getBackgroundColor() }]}>
      <View style={styles.iconContainer}>
        <Ionicons name={getIconName()} size={24} color="#991B1B" />
      </View>
      
      <View style={styles.contentContainer}>
        <Text style={styles.title}>{error.displayMessage}</Text>
        
        {error.recommendedAction && (
          <Text style={styles.message}>{error.recommendedAction}</Text>
        )}
        
        <View style={styles.actionsContainer}>
          {error.recoverable && onRetry && (
            <Pressable style={styles.retryButton} onPress={onRetry}>
              <Text style={styles.retryText}>Försök igen</Text>
            </Pressable>
          )}
          
          {onDismiss && (
            <Pressable 
              style={[
                styles.dismissButton, 
                !error.recoverable && { backgroundColor: '#991B1B' }
              ]} 
              onPress={onDismiss}
            >
              <Text 
                style={[
                  styles.dismissText, 
                  !error.recoverable && { color: '#FFF' }
                ]}
              >
                {error.recoverable ? 'Avbryt' : 'OK'}
              </Text>
            </Pressable>
          )}
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 8,
    padding: 16,
    marginVertical: 8,
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  iconContainer: {
    marginRight: 12,
    marginTop: 2,
  },
  contentContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#991B1B',
    marginBottom: 4,
  },
  message: {
    fontSize: 14,
    color: '#4B5563',
    marginBottom: 12,
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 8,
  },
  retryButton: {
    backgroundColor: '#991B1B',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 4,
    marginRight: 8,
  },
  retryText: {
    color: '#FFFFFF',
    fontWeight: '600',
    fontSize: 14,
  },
  dismissButton: {
    backgroundColor: '#F3F4F6',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 4,
  },
  dismissText: {
    color: '#4B5563',
    fontWeight: '600',
    fontSize: 14,
  },
});
```

### 7. Implementera en global felhanterare i React Native

Skapa en global felhanterare för frontend-applikationen:

```tsx
// src/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as Updates from 'expo-updates';
import { captureException } from '../utils/errorReporting';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Logga felet till rapporteringstjänst
    captureException(error, { extra: { componentStack: errorInfo.componentStack } });
    console.error('App crashed with error:', error, errorInfo);
  }

  handleRestart = async () => {
    try {
      await Updates.reloadAsync();
    } catch (error) {
      // Om reload misslyckas, försök en annan metod
      if (__DEV__) {
        console.log('Reloading app in dev mode...');
        // I utvecklingsläge, låt användaren manuellt ladda om
      } else {
        // I produktionsläge, forcera en reload av hela appen
        console.log('Forcing app reload...');
        Updates.checkForUpdateAsync()
          .then(() => Updates.fetchUpdateAsync())
          .then(() => Updates.reloadAsync())
          .catch(e => console.error('Failed to force reload:', e));
      }
    }
  };

  render() {
    if (this.state.hasError) {
      // Anpassad felvisning
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      // Standardfelvisning
      return (
        <View style={styles.container}>
          <Ionicons name="alert-circle-outline" size={48} color="#991B1B" />
          <Text style={styles.title}>Oj! Något gick fel</Text>
          <Text style={styles.message}>
            Vi ber om ursäkt för besväret. Appen stötte på ett problem som den inte kunde återhämta sig från.
          </Text>
          
          {__DEV__ && this.state.error && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorTitle}>{this.state.error.name}</Text>
              <Text style={styles.errorMessage}>{this.state.error.message}</Text>
              <Text style={styles.errorStack}>{this.state.error.stack}</Text>
            </View>
          )}
          
          <Pressable style={styles.button} onPress={this.handleRestart}>
            <Text style={styles.buttonText}>Starta om appen</Text>
          </Pressable>
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#FEE2E2',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#991B1B',
    marginTop: 16,
    marginBottom: 8,
  },
  message: {
    fontSize: 16,
    color: '#4B5563',
    textAlign: 'center',
    marginBottom: 24,
  },
  button: {
    backgroundColor: '#991B1B',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonText: {
    color: '#FFFFFF',
    fontWeight: 'bold',
    fontSize: 16,
  },
  errorContainer: {
    marginVertical: 16,
    padding: 16,
    backgroundColor: 'rgba(0, 0, 0, 0.05)',
    borderRadius: 8,
    width: '100%',
  },
  errorTitle: {
    fontWeight: 'bold',
    color: '#991B1B',
    marginBottom: 4,
  },
  errorMessage: {
    marginBottom: 8,
    color: '#4B5563',
  },
  errorStack: {
    fontFamily: 'monospace',
    fontSize: 12,
    color: '#6B7280',
  },
});
```

### 8. Skapa en tjänst för felregistrering och övervakning

Implementera en tjänst för att registrera och övervaka fel:

```typescript
// src/utils/errorReporting.ts
import * as Sentry from '@sentry/react-native';
import { Platform } from 'react-native';
import * as Device from 'expo-device';
import Constants from 'expo-constants';
import { ApiError } from './errorHandler';

// Konfigurera Sentry
export function initializeErrorReporting() {
  if (!__DEV__) { // Aktivera endast i produktionsmiljö
    Sentry.init({
      dsn: Constants.expoConfig?.extra?.SENTRY_DSN || '',
      environment: __DEV__ ? 'development' : 'production',
      debug: __DEV__,
      enableAutoSessionTracking: true,
      sessionTrackingIntervalMillis: 30000,
    });
    
    // Lägg till enhetsinfo
    Sentry.setTags({
      deviceName: Device.deviceName,
      deviceYearClass: Device.deviceYearClass?.toString(),
      deviceType: Device.deviceType,
      osName: Device.osName,
      osVersion: Device.osVersion,
      platform: Platform.OS,
      platformVersion: Platform.Version.toString(),
      appVersion: Constants.expoConfig?.version || '',
      appBuildNumber: Platform.OS === 'ios' 
        ? Constants.expoConfig?.ios?.buildNumber 
        : Constants.expoConfig?.android?.versionCode?.toString(),
    });
  }
}

// Funktion för att registrera fel
export function captureException(error: Error | ApiError, context?: any) {
  console.error('Error captured:', error);
  
  if (!__DEV__) {
    // Formatera extra data för Sentry
    const extras = {
      ...(context || {}),
    };
    
    // Om det är ett ApiError, lägg till dess egenskaper
    if ('type' in error) {
      const apiError = error as ApiError;
      extras.errorType = apiError.type;
      extras.errorCode = apiError.code;
      extras.errorDetails = apiError.details;
      extras.recoverable = apiError.recoverable;
    }
    
    // Registrera i Sentry
    Sentry.captureException(error, {
      extra: extras,
    });
  }
}

// Funktion för att registrera en händelse
export function captureMessage(message: string, level?: Sentry.Severity, context?: any) {
  console.log(`[${level || 'info'}] ${message}`, context);
  
  if (!__DEV__) {
    Sentry.captureMessage(message, {
      level: level || Sentry.Severity.Info,
      extra: context,
    });
  }
}

// Funktion för att sätta användarkontext
export function setUserContext(userId: string | null, extraInfo?: any) {
  if (!__DEV__ && userId) {
    Sentry.setUser({
      id: userId,
      ...extraInfo
    });
  } else if (!__DEV__ && !userId) {
    Sentry.setUser(null);
  }
}
```

### 9. Uppdatera appvisningslager för att hantera fel

Uppdatera app-komponenten för att korrekt visa och hantera fel:

```tsx
// Uppdatera App.tsx eller motsvarande huvudkomponent

import React, { useEffect, useState } from 'react';
import { ErrorBoundary } from './components/ErrorBoundary';
import { initializeErrorReporting, setUserContext } from './utils/errorReporting';
import { useAuth } from './providers/AuthProvider';
import { setupNetworkListener, NetworkStatus } from './utils/networkUtils';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

// Komponent för nätverksstatus
const OfflineNotice: React.FC<{ networkStatus: NetworkStatus }> = ({ networkStatus }) => {
  if (networkStatus.isConnected === false) {
    return (
      <View style={styles.offlineContainer}>
        <Ionicons name="cloud-offline-outline" size={16} color="#FFFFFF" />
        <Text style={styles.offlineText}>Du är offline</Text>
      </View>
    );
  }
  
  if (networkStatus.isInternetReachable === false) {
    return (
      <View style={styles.limitedContainer}>
        <Ionicons name="warning-outline" size={16} color="#FFFFFF" />
        <Text style={styles.offlineText}>Begränsad anslutning</Text>
      </View>
    );
  }
  
  return null;
};

function App() {
  const { user } = useAuth();
  const [networkStatus, setNetworkStatus] = useState<NetworkStatus>({
    isConnected: true,
    isInternetReachable: true,
    type: 'unknown',
    details: null,
    lastUpdated: Date.now()
  });
  
  // Initialisera felrapportering vid start
  useEffect(() => {
    initializeErrorReporting();
    
    // Konfigurera nätverksstatuslysnare
    const unsubscribe = setupNetworkListener(status => {
      setNetworkStatus(status);
    });
    
    return () => {
      unsubscribe();
    };
  }, []);
  
  // Uppdatera användarkontext för felrapportering
  useEffect(() => {
    if (user) {
      setUserContext(user.id, {
        email: user.email
      });
    } else {
      setUserContext(null);
    }
  }, [user]);
  
  return (
    <ErrorBoundary>
      {/* App RouterProvider eller NavigationContainer */}
      <AppRouter />
      
      {/* Nätverksstatusmeddelande */}
      <OfflineNotice networkStatus={networkStatus} />
    </ErrorBoundary>
  );
}

const styles = StyleSheet.create({
  offlineContainer: {
    position: 'absolute',
    top: 30,
    left: 0,
    right: 0,
    backgroundColor: '#991B1B',
    padding: 10,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  limitedContainer: {
    position: 'absolute',
    top: 30,
    left: 0,
    right: 0,
    backgroundColor: '#D97706',
    padding: 10,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  offlineText: {
    color: '#FFFFFF',
    marginLeft: 8,
    fontWeight: '600',
  }
});

export default App;
```

### 10. Uppdatera kamerasidan för att hantera videoanalyseringfel

Förbättra kamerasidan för att hantera videofel:

```tsx
// Uppdatera src/screens/CameraScreen.tsx

import React, { useState, useRef } from 'react';
import { View, Alert, StyleSheet } from 'react-native';
import { ErrorDisplay } from '../components/ErrorDisplay';
import { ApiError, ErrorType, convertErrorToApiError } from '../utils/errorHandler';
import { createApiError } from '../utils/errorHandler';
import { withRetry } from '../utils/retryUtils';
import { validateNetworkConnection } from '../utils/networkUtils';

// I din CameraScreen-komponent, hantera fel mer detaljerat:

const processVideo = async (videoPath: string) => {
  setProcessing(true);
  setError(null);
  
  try {
    // Validera nätverksanslutning innan videobearbetning
    await validateNetworkConnection();
    
    // Läs video och bearbeta
    const videoBase64 = await RNFS.readFile(videoPath, 'base64');
    
    // Använd withRetry för att hantera tillfälliga fel
    const result = await withRetry(
      async () => {
        const response = await fetch('https://din-backend.fly.dev/analyze', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            video: `data:video/mp4;base64,${videoBase64}`,
            userId: await getUserId()
          }),
        });
        
        if (!response.ok) {
          // Konvertera HTTP-fel till ApiError
          let errorMessage = 'Analys misslyckades';
          try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorMessage;
          } catch (e) {
            // Om feldata inte kan tolkas, använd standardmeddelande
          }
          
          throw createApiError(
            response.status === 429 ? ErrorType.API_QUOTA_EXCEEDED : ErrorType.API_RESPONSE_ERROR,
            errorMessage,
            {
              code: response.status,
              recoverable: response.status < 500,
            }
          );
        }
        
        return await response.json();
      },
      {
        maxRetries: 2,
        retryableErrors: [
          ErrorType.NETWORK_ERROR,
          ErrorType.API_CONNECTION_ERROR,
          ErrorType.TIMEOUT_ERROR
        ]
      }
    );
    
    // Fortsätt med lyckad analys...
    
  } catch (err) {
    // Konvertera felet till ett standardiserat ApiError
    const apiError = convertErrorToApiError(err);
    setError(apiError);
    
    // Loggning och rapportering av felet
    captureException(apiError, { screen: 'Camera', action: 'processVideo' });
  } finally {
    setProcessing(false);
  }
};

// I renderingslogiken, visa fel på ett användarvänligt sätt
return (
  <View style={styles.container}>
    {/* Kameravisning, knappar etc. */}
    
    {error && (
      <ErrorDisplay
        error={error}
        onRetry={() => {
          if (videoPath) {
            processVideo(videoPath);
          }
        }}
        onDismiss={() => {
          setError(null);
          handleBack();
        }}
      />
    )}
  </View>
);
```

### 11. Förbättra backend-endpoints för att hantera specialfel för Gemini

Uppdatera huvudendpoint för att hantera Gemini-specifika fel:

```typescript
// Uppdatera src/routes/analyzeRoutes.ts

import { Router } from 'express';
import { createApiError, ErrorType } from '../utils/errorHandler';
import { withRetry } from '../utils/retryUtils';

// I din endpoint-handler:
router.post('/analyze', async (req, res, next) => {
  try {
    const { image, video, ingredients, isOfflineAnalysis, userId } = req.body;
    
    // Om användaren har nått analyskvoten
    if (userId) {
      try {
        const userLimit = await checkUserLimit(userId);
        
        if (!userLimit.hasRemainingAnalyses) {
          throw createApiError(
            ErrorType.API_QUOTA_EXCEEDED,
            'User has reached analysis quota',
            {
              details: {
                analysesUsed: userLimit.analysesUsed,
                analysesLimit: userLimit.analysesLimit,
                isPremium: userLimit.isPremium
              },
              code: 403,
              recoverable: false,
              displayMessage: 'Du har nått din månatliga gräns för analyser',
              recommendedAction: userLimit.isPremium 
                ? 'Vänta till nästa månad för att få nya analyser' 
                : 'Uppgradera till premiumversionen för att få fler analyser'
            }
          );
        }
      } catch (error) {
        // Logga felet men fortsätt (vi vill inte blockera analysen om kvotkontrollen misslyckas)
        logger.error('Error checking user limit', { 
          error,
          userId
        });
      }
    }
    
    // Kontroller för olika indata
    if (!image && !video && (!ingredients || !Array.isArray(ingredients))) {
      throw createApiError(
        ErrorType.CONTENT_VALIDATION_ERROR,
        'No valid input provided',
        {
          code: 400,
          recoverable: true,
          displayMessage: 'Ingen giltig indata hittades',
          recommendedAction: 'Skicka en bild, video eller ingredienslista'
        }
      );
    }
    
    // Resten av implementationen...
    
  } catch (error) {
    // Använd next() för att skicka felet till felhanteringsmiddleware
    next(error);
  }
});

// I din app.ts eller server.ts, lägg till felhanteringsmiddleware sist
import { errorMiddleware } from './utils/errorHandler';

// Middlewares och routes...

// Lägg till global felhantering sist i appen
app.use(errorMiddleware);
```

## Verifiering

För att verifiera att felhanteringen fungerar korrekt:

1. Testa offline-/onlinehantering:
```bash
# Simulera dålig nätverksanslutning
# I development-läge, använd Chrome DevTools:
# - Öppna Network-fliken
# - Ändra till "Offline" eller "Slow 3G"
```

2. Testa API-gränsfel:
```bash
# Skapa ett test med ogiltigt API-nyckel
curl -X POST http://localhost:3000/analyze \
  -H "Content-Type: application/json" \
  -d '{"ingredients": ["Test"], "invalidApiKey": true}'
```

3. Testa videobearbetningsfel:
```bash
# Skicka en ogiltig video (t.ex. en tom fil)
curl -X POST http://localhost:3000/analyze \
  -H "Content-Type: application/json" \
  -d '{"video": "data:video/mp4;base64,SGVsbG8="}'
```

4. Verifiera att ErrorBoundary fångar React-fel:
```typescript
// Lägg till en testkomponent som kastar ett fel
function TestErrorComponent() {
  throw new Error('Test error');
  return null;
}

// Använd komponenten i utvecklingsläge för att testa ErrorBoundary
```

5. Kontrollera att felrapportering fungerar:
```bash
# Verifiera att fel loggas i Sentry-dashboarden
# (Om konfigurerad) Kontrollera felrapporteringsanalyser
```

## Felsökning

### Problem: ErrorBoundary fångar inte alla fel
**Lösning**: Kontrollera att asynkrona fel hanteras korrekt:
```typescript
try {
  await someAsyncFunction();
} catch (error) {
  captureException(error);
  // Hantera felet lokalt
}
```

### Problem: Felmeddelanden är inte användarinriktade
**Lösning**: Kontrollera att displayMessage-egenskapen används:
```typescript
throw createApiError(
  ErrorType.API_RESPONSE_ERROR,
  'Technical error message',
  {
    displayMessage: 'Användarvänligt meddelande om vad som gick fel'
  }
);
```

### Problem: Återförsök överbelastar servern
**Lösning**: Justera återförsökslogiken för att hantera backoff-strategi:
```typescript
// Ändra backoffFactor och maxDelay
const retryOptions: RetryOptions = {
  ...defaultRetryOptions,
  backoffFactor: 3, // Mer aggressiv backoff
  maxDelay: 20000, // Längre maximal fördröjning
};
```

## Nästa steg

Nu när du har implementerat en robust felhanteringsstrategi är du redo att gå vidare till driftsättningsfasen av projektet. Nästa steg är "Staging-driftsättning" där du kommer att driftsätta applikationen på en testmiljö innan produktionslansering.

## Referenser
- [Google Gemini API Error Handling](https://ai.google.dev/docs/gemini_api/error_codes)
- [React Native Error Handling Best Practices](https://reactnative.dev/docs/error-handling)
- [Expo Updates API](https://docs.expo.dev/versions/latest/sdk/updates/)
- [Sentry for React Native](https://docs.sentry.io/platforms/react-native/)
- [Network Information API for React Native](https://github.com/react-native-netinfo/react-native-netinfo)
